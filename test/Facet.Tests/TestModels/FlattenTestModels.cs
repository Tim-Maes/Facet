using System;

namespace Facet.Tests.TestModels;

// Test models for Flatten attribute

public class Person
{
    public int Id { get; set; }
    public string FirstName { get; set; } = string.Empty;
    public string LastName { get; set; } = string.Empty;
    public DateTime DateOfBirth { get; set; }
    public Address Address { get; set; } = null!;
    public ContactInfo ContactInfo { get; set; } = null!;
}

public class Address
{
    public string Street { get; set; } = string.Empty;
    public string City { get; set; } = string.Empty;
    public string ZipCode { get; set; } = string.Empty;
    public Country Country { get; set; } = null!;
}

public class Country
{
    public string Name { get; set; } = string.Empty;
    public string Code { get; set; } = string.Empty;
}

public class ContactInfo
{
    public string Email { get; set; } = string.Empty;
    public string Phone { get; set; } = string.Empty;
}

// Flattened DTOs

[Flatten(typeof(Person))]
public partial class PersonFlatDto
{
    // All properties generated by source generator
}

[Flatten(typeof(Person), MaxDepth = 2)]
public partial class PersonFlatDepth2Dto
{
    // Limited to 2 levels deep
}

[Flatten(typeof(Person), "ContactInfo")]
public partial class PersonFlatWithoutContactDto
{
    // Excludes ContactInfo properties
}

[Flatten(typeof(Person), "Address.Country")]
public partial class PersonFlatWithoutCountryDto
{
    // Excludes nested Country properties
}

[Flatten(typeof(Person), NamingStrategy = FlattenNamingStrategy.LeafOnly)]
public partial class PersonFlatLeafOnlyDto
{
    // Uses leaf-only naming strategy
}

// Test models for collections
public class Company
{
    public int Id { get; set; }
    public string Name { get; set; } = string.Empty;
    public Address HeadquartersAddress { get; set; } = null!;
    public List<Worker> Workers { get; set; } = new();
}

public class Worker
{
    public int Id { get; set; }
    public string Name { get; set; } = string.Empty;
    public string Title { get; set; } = string.Empty;
    public int CompanyId { get; set; }
}

[Flatten(typeof(Company))]
public partial class CompanyFlatDto
{
    // Collections should be completely ignored - no Count, IsReadOnly, or Worker properties
}

// Test models for nested IDs
public class Order
{
    public int Id { get; set; }
    public DateTime OrderDate { get; set; }
    public int CustomerId { get; set; }
    public Customer Customer { get; set; } = null!;
    public decimal Total { get; set; }
}

public class Customer
{
    public int Id { get; set; }
    public string Name { get; set; } = string.Empty;
    public string Email { get; set; } = string.Empty;
    public int? PreferredAddressId { get; set; }
}

[Flatten(typeof(Order), IgnoreNestedIds = true)]
public partial class OrderFlatDto
{
    // Only Order.Id should be included
    // Customer.Id, Order.CustomerId, and Customer.PreferredAddressId should be excluded
}

[Flatten(typeof(Order), IgnoreNestedIds = false)]
public partial class OrderFlatWithAllIdsDto
{
    // All IDs should be included for comparison
}

// Test models for FK clashes
public class PersonWithFk
{
    public int Id { get; set; }
    public string Name { get; set; } = string.Empty;
    public int? AddressId { get; set; } // Foreign key
    public AddressWithId? Address { get; set; } // Navigation property
}

public class AddressWithId
{
    public int Id { get; set; }
    public string Line1 { get; set; } = string.Empty;
    public string Line2 { get; set; } = string.Empty;
    public string City { get; set; } = string.Empty;
}

[Flatten(typeof(PersonWithFk), IgnoreForeignKeyClashes = true)]
public partial class PersonWithFkFlatDto
{
    // AddressId (FK) should be included
    // Address.Id should be skipped (would clash with AddressId)
    // Other Address properties (Line1, City, etc.) should be included as AddressLine1, AddressCity, etc.
}

[Flatten(typeof(PersonWithFk), IgnoreForeignKeyClashes = false)]
public partial class PersonWithFkFlatNoIgnoreDto
{
    // AddressId (FK) should be included
    // Address.Id should be included as AddressId2 (name collision)
    // Other Address properties should be included
}

// Test model with multiple FKs
public class OrderWithFks
{
    public int Id { get; set; }
    public DateTime OrderDate { get; set; }
    public int CustomerId { get; set; } // FK
    public CustomerWithAddress Customer { get; set; } = null!;
    public int? ShippingAddressId { get; set; } // FK
    public AddressWithId? ShippingAddress { get; set; }
}

public class CustomerWithAddress
{
    public int Id { get; set; }
    public string Name { get; set; } = string.Empty;
    public string Email { get; set; } = string.Empty;
    public int? HomeAddressId { get; set; } // Nested FK
    public AddressWithId? HomeAddress { get; set; }
}

[Flatten(typeof(OrderWithFks), IgnoreForeignKeyClashes = true)]
public partial class OrderWithFksFlatDto
{
    // Should include: Id, OrderDate, CustomerId (FK), ShippingAddressId (FK)
    // Should skip: Customer.Id, Customer.HomeAddressId, ShippingAddress.Id, Customer.HomeAddress.Id
    // Should include: CustomerName, CustomerEmail, ShippingAddressLine1, etc.
}

// Test models for SmartLeaf naming strategy
public class Position
{
    public int Id { get; set; }
    public string Name { get; set; } = string.Empty;
}

public class ItemType
{
    public int Id { get; set; }
    public string Name { get; set; } = string.Empty;
}

public class ExtendedData
{
    public int Id { get; set; }
    public int PositionId { get; set; }
    public Position Position { get; set; } = null!;
    public int TypeId { get; set; }
    public ItemType Type { get; set; } = null!;
}

public class DataItem
{
    public int Id { get; set; }
    public string DataValue { get; set; } = string.Empty;
    public int ExtendedDataId { get; set; }
    public ExtendedData ExtendedData { get; set; } = null!;
}

[Flatten(typeof(DataItem), NamingStrategy = FlattenNamingStrategy.SmartLeaf, IgnoreNestedIds = true)]
public partial class DataItemSmartLeafDto
{
    // Expected properties:
    // Id (root)
    // DataValue (no collision)
    // PositionName (collision resolved with parent)
    // TypeName (collision resolved with parent)
}

[Flatten(typeof(DataItem), NamingStrategy = FlattenNamingStrategy.LeafOnly, IgnoreNestedIds = true)]
public partial class DataItemLeafOnlyDto
{
    // Expected properties with numeric suffixes:
    // Id, DataValue, Name, Name2
}

// Test model with multiple collisions from same parent
public class CatalogProduct
{
    public int Id { get; set; }
    public string Name { get; set; } = string.Empty;
    public string Code { get; set; } = string.Empty;
}

public class CatalogCategory
{
    public int Id { get; set; }
    public string Name { get; set; } = string.Empty;
    public string Code { get; set; } = string.Empty;
}

public class ProductCatalog
{
    public int Id { get; set; }
    public CatalogProduct Product { get; set; } = null!;
    public CatalogCategory Category { get; set; } = null!;
}

[Flatten(typeof(ProductCatalog), NamingStrategy = FlattenNamingStrategy.SmartLeaf, IgnoreNestedIds = true)]
public partial class ProductCatalogSmartLeafDto
{
    // Expected properties:
    // Id
    // ProductName, ProductCode (collisions resolved)
    // CategoryName, CategoryCode (collisions resolved)
}

// Test models for FlattenTo feature
public class DataEntity
{
    public int Id { get; set; }
    public string Name { get; set; } = string.Empty;
    public string Description { get; set; } = string.Empty;
    public ICollection<ExtendedEntity> Extended { get; set; } = new List<ExtendedEntity>();
}

public class ExtendedEntity
{
    public int Id { get; set; }
    public string Name { get; set; } = string.Empty;
    public int DataValue { get; set; }
}

// Facet for ExtendedEntity
[Facet(typeof(ExtendedEntity))]
public partial class ExtendedFacet;

// Facet for DataEntity with FlattenTo
[Facet(typeof(DataEntity), NestedFacets = [typeof(ExtendedFacet)], FlattenTo = [typeof(DataFlattenedDto)])]
public partial class DataFacet;

// Flattened DTO that combines DataEntity and ExtendedEntity properties
// The user manually specifies which properties from both parent and child they want
// The FlattenTo method will populate these from DataFacet (parent) and each Extended item (child)
public partial class DataFlattenedDto
{
    // Properties from DataEntity (parent)
    public int Id { get; set; }
    public string Name { get; set; } = string.Empty;
    public string Description { get; set; } = string.Empty;
    
    // Properties from ExtendedEntity (collection item)
    // Note: ExtendedName avoids collision with parent's Name property
    public string ExtendedName { get; set; } = string.Empty;
    public int DataValue { get; set; }
}

// Test models for FlattenTo with lookup/junction tables and nested facets
public class DataTableEntity
{
    public int Id { get; set; }
    public string Name { get; set; } = string.Empty;
    public ICollection<DataExtendedLookupEntity> ExtendedLookups { get; set; } = new List<DataExtendedLookupEntity>();
}

public class DataExtendedLookupEntity
{
    public int Id { get; set; }
    public int DataId { get; set; }
    public DataTableEntity Data { get; set; } = null!;
    public int ExtendedId { get; set; }
    public DataExtendedEntity Extended { get; set; } = null!;
}

public class DataExtendedEntity
{
    public int Id { get; set; }
    public string ExtendedValue { get; set; } = string.Empty;
    public int NumericValue { get; set; }
}

// Facets
[Facet(typeof(DataExtendedEntity))]
public partial class DataExtendedFacet;

[Facet(typeof(DataExtendedLookupEntity),
    NestedFacets = [typeof(DataExtendedFacet)])]
public partial class DataExtendedLookupFacet;

[Facet(typeof(DataTableEntity),
    NestedFacets = [typeof(DataExtendedLookupFacet)],
    FlattenTo = [typeof(DataTableFlattenedDto)])]
public partial class DataTableFacet;

// Flattened DTO - should include properties from both the lookup and the nested Extended entity
public partial class DataTableFlattenedDto
{
    // From DataTableEntity (parent)
    public int Id { get; set; }
    public string Name { get; set; } = string.Empty;

    // From DataExtendedLookupEntity (collection item)
    public int DataId { get; set; }
    public int ExtendedId { get; set; }

    // From DataExtendedEntity (nested within collection item) - THIS IS THE BUG
    // These properties should be populated by traversing through ExtendedLookups[].Extended.*
    public string ExtendedValue { get; set; } = string.Empty;
    public int NumericValue { get; set; }
}

// Test models for FlattenTo with multiple Name property collisions (Issue #196)
// This scenario tests SmartLeaf naming when multiple nested paths have properties with the same name
public class ProductCatalogEntity
{
    public int Id { get; set; }
    public string Name { get; set; } = string.Empty;
    public ICollection<ProductLookupEntity> ProductLookups { get; set; } = new List<ProductLookupEntity>();
}

public class ProductLookupEntity
{
    public int Id { get; set; }
    public CategoryEntity Category { get; set; } = null!;
    public SupplierEntity Supplier { get; set; } = null!;
    public BrandEntity Brand { get; set; } = null!;
}

public class CategoryEntity
{
    public int Id { get; set; }
    public string Name { get; set; } = string.Empty;  // Will collide
    public string Code { get; set; } = string.Empty;
}

public class SupplierEntity
{
    public int Id { get; set; }
    public string Name { get; set; } = string.Empty;  // Will collide
    public string ContactEmail { get; set; } = string.Empty;
}

public class BrandEntity
{
    public int Id { get; set; }
    public string Name { get; set; } = string.Empty;  // Will collide
    public string Country { get; set; } = string.Empty;
}

// Facets for SmartLeaf collision test
[Facet(typeof(CategoryEntity))]
public partial class CategoryFacet;

[Facet(typeof(SupplierEntity))]
public partial class SupplierFacet;

[Facet(typeof(BrandEntity))]
public partial class BrandFacet;

[Facet(typeof(ProductLookupEntity),
    NestedFacets = [typeof(CategoryFacet), typeof(SupplierFacet), typeof(BrandFacet)])]
public partial class ProductLookupFacet;

[Facet(typeof(ProductCatalogEntity),
    NestedFacets = [typeof(ProductLookupFacet)],
    FlattenTo = [typeof(ProductCatalogFlattenedDto)])]
public partial class ProductCatalogFacet;

// Flattened DTO with SmartLeaf naming for collision resolution
public partial class ProductCatalogFlattenedDto
{
    // From ProductCatalogEntity (parent)
    public int Id { get; set; }
    public string Name { get; set; } = string.Empty;

    // From nested entities - SmartLeaf naming prefixes only when collisions occur
    public string CategoryName { get; set; } = string.Empty;      // From Category.Name (prefixed due to collision)
    public string Code { get; set; } = string.Empty;              // From Category.Code (no collision, no prefix)

    public string SupplierName { get; set; } = string.Empty;      // From Supplier.Name (prefixed due to collision)
    public string ContactEmail { get; set; } = string.Empty;      // From Supplier.ContactEmail (no collision, no prefix)

    public string BrandName { get; set; } = string.Empty;         // From Brand.Name (prefixed due to collision)
    public string Country { get; set; } = string.Empty;           // From Brand.Country (no collision, no prefix)
}

// Test models for IncludeCollections feature (GitHub issue #242)
public class ApiResponse
{
    public int Id { get; set; }
    public string Name { get; set; } = string.Empty;
    public ResponseMetadata Metadata { get; set; } = null!;
    public List<ResponseItem> Items { get; set; } = new();
    public string[] Tags { get; set; } = Array.Empty<string>();
}

public class ResponseMetadata
{
    public DateTime CreatedAt { get; set; }
    public string Version { get; set; } = string.Empty;
}

public class ResponseItem
{
    public int ItemId { get; set; }
    public string ItemName { get; set; } = string.Empty;
    public decimal Price { get; set; }
}

// Flatten WITH collections included
[Flatten(typeof(ApiResponse), IncludeCollections = true)]
public partial class ApiResponseFlatWithCollectionsDto
{
    // Should include:
    // - Id
    // - Name
    // - MetadataCreatedAt
    // - MetadataVersion
    // - Items (List<ResponseItem> - collection included as-is)
    // - Tags (string[] - collection included as-is)
}

// Flatten WITHOUT collections (default behavior)
[Flatten(typeof(ApiResponse))]
public partial class ApiResponseFlatWithoutCollectionsDto
{
    // Should include:
    // - Id
    // - Name
    // - MetadataCreatedAt
    // - MetadataVersion
    // (Items and Tags should be excluded)
}

// Test with IEnumerable and ICollection
public class EntityWithVariousCollections
{
    public int Id { get; set; }
    public string Name { get; set; } = string.Empty;
    public IEnumerable<string> Emails { get; set; } = Enumerable.Empty<string>();
    public ICollection<int> Numbers { get; set; } = new List<int>();
    public IList<DateTime> Dates { get; set; } = new List<DateTime>();
    public HashSet<string> UniqueValues { get; set; } = new();
}

[Flatten(typeof(EntityWithVariousCollections), IncludeCollections = true)]
public partial class EntityWithVariousCollectionsFlatDto
{
    // All collection types should be included as-is
}
