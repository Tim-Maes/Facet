// <auto-generated />
#nullable enable

using System;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.EntityFrameworkCore;
using Facet.Extensions;

namespace Facet.Extensions.EFCore.Tests.TestData;

/// <summary>
/// Fluent builder for OrderItem with navigation inclusion.
/// </summary>
public sealed class FacetOrderItemBuilder<TShape>
    where TShape : class
{
    private readonly IQueryable<Facet.Extensions.EFCore.Tests.TestData.OrderItem> _query;
    private readonly List<string> _includes = new();

    public FacetOrderItemBuilder(IQueryable<Facet.Extensions.EFCore.Tests.TestData.OrderItem> query)
    {
        _query = query;
    }

    /// <summary>
    /// Include the Order navigation in the query.
    /// </summary>
    public FacetOrderItemBuilder<IOrderItemWithOrder<IOrderShape>> WithOrder()
    {
        var newQuery = _query.Include(x => x.Order);
        var newBuilder = new FacetOrderItemBuilder<IOrderItemWithOrder<IOrderShape>>(newQuery);
        newBuilder._includes.AddRange(_includes);
        newBuilder._includes.Add("Order");
        return newBuilder;
    }

    /// <summary>
    /// Include the Order navigation with nested navigation configuration.
    /// </summary>
    public FacetOrderItemBuilder<IOrderItemWithOrder<TNestedShape>> WithOrder<TNestedShape>(
        Func<FacetOrderBuilder<IOrderShape>, FacetOrderBuilder<TNestedShape>> configure)
        where TNestedShape : class
    {
        // This would require more complex EF Include handling for nested paths
        throw new NotImplementedException("Nested navigation configuration not yet implemented");
    }

    /// <summary>
    /// Include the Product navigation in the query.
    /// </summary>
    public FacetOrderItemBuilder<IOrderItemWithProduct<IProductShape>> WithProduct()
    {
        var newQuery = _query.Include(x => x.Product);
        var newBuilder = new FacetOrderItemBuilder<IOrderItemWithProduct<IProductShape>>(newQuery);
        newBuilder._includes.AddRange(_includes);
        newBuilder._includes.Add("Product");
        return newBuilder;
    }

    /// <summary>
    /// Include the Product navigation with nested navigation configuration.
    /// </summary>
    public FacetOrderItemBuilder<IOrderItemWithProduct<TNestedShape>> WithProduct<TNestedShape>(
        Func<FacetProductBuilder<IProductShape>, FacetProductBuilder<TNestedShape>> configure)
        where TNestedShape : class
    {
        // This would require more complex EF Include handling for nested paths
        throw new NotImplementedException("Nested navigation configuration not yet implemented");
    }

    /// <summary>
    /// Apply an entity predicate to the underlying OrderItem query without changing the current shape.
    /// </summary>
    public FacetOrderItemBuilder<TShape> Where(System.Linq.Expressions.Expression<Func<Facet.Extensions.EFCore.Tests.TestData.OrderItem, bool>> predicate)
    {
        if (predicate == null) throw new ArgumentNullException(nameof(predicate));
        var newQuery = _query.Where(predicate);
        var newBuilder = new FacetOrderItemBuilder<TShape>(newQuery);
        newBuilder._includes.AddRange(_includes);
        return newBuilder;
    }
    /// <summary>
    /// Get a single OrderItem by ID.
    /// </summary>
    public async Task<TShape?> GetByIdAsync(object id, CancellationToken cancellationToken = default)
    {
        // For now, use simple Id-based filtering
        // TODO: Enhance to use EF metadata for primary key discovery
        var query = _query.Where(e => EF.Property<object>(e, "Id") == id);

        // Use SelectFacet to project to TShape
        return await query.SelectFacet<TShape>().FirstOrDefaultAsync(cancellationToken);
    }

    /// <summary>
    /// Execute the query and return a list of OrderItem shapes.
    /// </summary>
    public async Task<List<TShape>> ToListAsync(CancellationToken cancellationToken = default)
    {
        // Use SelectFacet to project to TShape and execute query
        return await _query.SelectFacet<TShape>().ToListAsync(cancellationToken);
    }

    /// <summary>
    /// Execute the query and return the first OrderItem or default.
    /// </summary>
    public async Task<TShape?> FirstOrDefaultAsync(CancellationToken cancellationToken = default)
    {
        // Use SelectFacet to project to TShape and execute query
        return await _query.SelectFacet<TShape>().FirstOrDefaultAsync(cancellationToken);
    }

    /// <summary>
    /// Project the current query to a DTO using Facet Projection.
    /// </summary>
    public IQueryable<TDto> ProjectTo<TDto>() where TDto : class
    {
        return _query.SelectFacet<TDto>();
    }

    /// <summary>
    /// Execute the query and return DTOs using Facet Projection.
    /// </summary>
    public async Task<List<TDto>> ToListDtoAsync<TDto>(CancellationToken cancellationToken = default) where TDto : class
    {
        return await _query.SelectFacet<TDto>().ToListAsync(cancellationToken);
    }

    /// <summary>
    /// Execute the query and return the first DTO or default using Facet Projection.
    /// </summary>
    public async Task<TDto?> FirstOrDefaultDtoAsync<TDto>(CancellationToken cancellationToken = default) where TDto : class
    {
        return await _query.SelectFacet<TDto>().FirstOrDefaultAsync(cancellationToken);
    }
}
