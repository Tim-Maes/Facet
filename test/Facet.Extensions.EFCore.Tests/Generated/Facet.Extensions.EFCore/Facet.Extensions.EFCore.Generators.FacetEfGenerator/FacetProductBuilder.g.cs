// <auto-generated />
#nullable enable

using System;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.EntityFrameworkCore;
using Facet.Extensions;

namespace Facet.Extensions.EFCore.Tests.TestData;

/// <summary>
/// Fluent builder for Product with navigation inclusion.
/// </summary>
public sealed class FacetProductBuilder<TShape>
    where TShape : class
{
    private readonly IQueryable<Facet.Extensions.EFCore.Tests.TestData.Product> _query;
    private readonly List<string> _includes = new();

    public FacetProductBuilder(IQueryable<Facet.Extensions.EFCore.Tests.TestData.Product> query)
    {
        _query = query;
    }

    /// <summary>
    /// Include the Category navigation in the query.
    /// </summary>
    public FacetProductBuilder<IProductWithCategory<ICategoryShape>> WithCategory()
    {
        var newQuery = _query.Include(x => x.Category);
        var newBuilder = new FacetProductBuilder<IProductWithCategory<ICategoryShape>>(newQuery);
        newBuilder._includes.AddRange(_includes);
        newBuilder._includes.Add("Category");
        return newBuilder;
    }

    /// <summary>
    /// Include the Category navigation with nested navigation configuration.
    /// </summary>
    public FacetProductBuilder<IProductWithCategory<TNestedShape>> WithCategory<TNestedShape>(
        Func<FacetCategoryBuilder<ICategoryShape>, FacetCategoryBuilder<TNestedShape>> configure)
        where TNestedShape : class
    {
        // This would require more complex EF Include handling for nested paths
        throw new NotImplementedException("Nested navigation configuration not yet implemented");
    }

    /// <summary>
    /// Include the OrderItems navigation in the query.
    /// </summary>
    public FacetProductBuilder<IProductWithOrderItems<IOrderItemShape>> WithOrderItems()
    {
        var newQuery = _query.Include(x => x.OrderItems);
        var newBuilder = new FacetProductBuilder<IProductWithOrderItems<IOrderItemShape>>(newQuery);
        newBuilder._includes.AddRange(_includes);
        newBuilder._includes.Add("OrderItems");
        return newBuilder;
    }

    /// <summary>
    /// Include the OrderItems navigation with nested navigation configuration.
    /// </summary>
    public FacetProductBuilder<IProductWithOrderItems<TNestedShape>> WithOrderItems<TNestedShape>(
        Func<FacetOrderItemBuilder<IOrderItemShape>, FacetOrderItemBuilder<TNestedShape>> configure)
        where TNestedShape : class
    {
        // This would require more complex EF Include handling for nested paths
        throw new NotImplementedException("Nested navigation configuration not yet implemented");
    }

    /// <summary>
    /// Apply an entity predicate to the underlying Product query without changing the current shape.
    /// </summary>
    public FacetProductBuilder<TShape> Where(System.Linq.Expressions.Expression<Func<Facet.Extensions.EFCore.Tests.TestData.Product, bool>> predicate)
    {
        if (predicate == null) throw new ArgumentNullException(nameof(predicate));
        var newQuery = _query.Where(predicate);
        var newBuilder = new FacetProductBuilder<TShape>(newQuery);
        newBuilder._includes.AddRange(_includes);
        return newBuilder;
    }
    /// <summary>
    /// Get a single Product by ID.
    /// </summary>
    public async Task<TShape?> GetByIdAsync(object id, CancellationToken cancellationToken = default)
    {
        // For now, use simple Id-based filtering
        // TODO: Enhance to use EF metadata for primary key discovery
        var query = _query.Where(e => EF.Property<object>(e, "Id") == id);

        // Use SelectFacet to project to TShape
        return await query.SelectFacet<TShape>().FirstOrDefaultAsync(cancellationToken);
    }

    /// <summary>
    /// Execute the query and return a list of Product shapes.
    /// </summary>
    public async Task<List<TShape>> ToListAsync(CancellationToken cancellationToken = default)
    {
        // Use SelectFacet to project to TShape and execute query
        return await _query.SelectFacet<TShape>().ToListAsync(cancellationToken);
    }

    /// <summary>
    /// Execute the query and return the first Product or default.
    /// </summary>
    public async Task<TShape?> FirstOrDefaultAsync(CancellationToken cancellationToken = default)
    {
        // Use SelectFacet to project to TShape and execute query
        return await _query.SelectFacet<TShape>().FirstOrDefaultAsync(cancellationToken);
    }

    /// <summary>
    /// Project the current query to a DTO using Facet Projection.
    /// </summary>
    public IQueryable<TDto> ProjectTo<TDto>() where TDto : class
    {
        return _query.SelectFacet<TDto>();
    }

    /// <summary>
    /// Execute the query and return DTOs using Facet Projection.
    /// </summary>
    public async Task<List<TDto>> ToListDtoAsync<TDto>(CancellationToken cancellationToken = default) where TDto : class
    {
        return await _query.SelectFacet<TDto>().ToListAsync(cancellationToken);
    }

    /// <summary>
    /// Execute the query and return the first DTO or default using Facet Projection.
    /// </summary>
    public async Task<TDto?> FirstOrDefaultDtoAsync<TDto>(CancellationToken cancellationToken = default) where TDto : class
    {
        return await _query.SelectFacet<TDto>().FirstOrDefaultAsync(cancellationToken);
    }
}
