// <auto-generated />
#nullable enable

using System;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.EntityFrameworkCore;
using Facet.Extensions;

namespace Facet.Extensions.EFCore.Tests.TestData;

/// <summary>
/// Fluent builder for Order with navigation inclusion.
/// </summary>
public sealed class FacetOrderBuilder<TShape>
    where TShape : class
{
    private readonly IQueryable<Facet.Extensions.EFCore.Tests.TestData.Order> _query;
    private readonly List<string> _includes = new();

    public FacetOrderBuilder(IQueryable<Facet.Extensions.EFCore.Tests.TestData.Order> query)
    {
        _query = query;
    }

    /// <summary>
    /// Include the OrderItems navigation in the query.
    /// </summary>
    public FacetOrderBuilder<IOrderWithOrderItems<IOrderItemShape>> WithOrderItems()
    {
        var newQuery = _query.Include(x => x.OrderItems);
        var newBuilder = new FacetOrderBuilder<IOrderWithOrderItems<IOrderItemShape>>(newQuery);
        newBuilder._includes.AddRange(_includes);
        newBuilder._includes.Add("OrderItems");
        return newBuilder;
    }

    /// <summary>
    /// Include the OrderItems navigation with nested navigation configuration.
    /// </summary>
    public FacetOrderBuilder<IOrderWithOrderItems<TNestedShape>> WithOrderItems<TNestedShape>(
        Func<FacetOrderItemBuilder<IOrderItemShape>, FacetOrderItemBuilder<TNestedShape>> configure)
        where TNestedShape : class
    {
        // This would require more complex EF Include handling for nested paths
        throw new NotImplementedException("Nested navigation configuration not yet implemented");
    }

    /// <summary>
    /// Include the User navigation in the query.
    /// </summary>
    public FacetOrderBuilder<IOrderWithUser<IUserShape>> WithUser()
    {
        var newQuery = _query.Include(x => x.User);
        var newBuilder = new FacetOrderBuilder<IOrderWithUser<IUserShape>>(newQuery);
        newBuilder._includes.AddRange(_includes);
        newBuilder._includes.Add("User");
        return newBuilder;
    }

    /// <summary>
    /// Include the User navigation with nested navigation configuration.
    /// </summary>
    public FacetOrderBuilder<IOrderWithUser<TNestedShape>> WithUser<TNestedShape>(
        Func<FacetUserBuilder<IUserShape>, FacetUserBuilder<TNestedShape>> configure)
        where TNestedShape : class
    {
        // This would require more complex EF Include handling for nested paths
        throw new NotImplementedException("Nested navigation configuration not yet implemented");
    }

    /// <summary>
    /// Apply an entity predicate to the underlying Order query without changing the current shape.
    /// </summary>
    public FacetOrderBuilder<TShape> Where(System.Linq.Expressions.Expression<Func<Facet.Extensions.EFCore.Tests.TestData.Order, bool>> predicate)
    {
        if (predicate == null) throw new ArgumentNullException(nameof(predicate));
        var newQuery = _query.Where(predicate);
        var newBuilder = new FacetOrderBuilder<TShape>(newQuery);
        newBuilder._includes.AddRange(_includes);
        return newBuilder;
    }
    /// <summary>
    /// Get a single Order by ID.
    /// </summary>
    public async Task<TShape?> GetByIdAsync(object id, CancellationToken cancellationToken = default)
    {
        // For now, use simple Id-based filtering
        // TODO: Enhance to use EF metadata for primary key discovery
        var query = _query.Where(e => EF.Property<object>(e, "Id") == id);

        // Use SelectFacet to project to TShape
        return await query.SelectFacet<TShape>().FirstOrDefaultAsync(cancellationToken);
    }

    /// <summary>
    /// Execute the query and return a list of Order shapes.
    /// </summary>
    public async Task<List<TShape>> ToListAsync(CancellationToken cancellationToken = default)
    {
        // Use SelectFacet to project to TShape and execute query
        return await _query.SelectFacet<TShape>().ToListAsync(cancellationToken);
    }

    /// <summary>
    /// Execute the query and return the first Order or default.
    /// </summary>
    public async Task<TShape?> FirstOrDefaultAsync(CancellationToken cancellationToken = default)
    {
        // Use SelectFacet to project to TShape and execute query
        return await _query.SelectFacet<TShape>().FirstOrDefaultAsync(cancellationToken);
    }

    /// <summary>
    /// Project the current query to a DTO using Facet Projection.
    /// </summary>
    public IQueryable<TDto> ProjectTo<TDto>() where TDto : class
    {
        return _query.SelectFacet<TDto>();
    }

    /// <summary>
    /// Execute the query and return DTOs using Facet Projection.
    /// </summary>
    public async Task<List<TDto>> ToListDtoAsync<TDto>(CancellationToken cancellationToken = default) where TDto : class
    {
        return await _query.SelectFacet<TDto>().ToListAsync(cancellationToken);
    }

    /// <summary>
    /// Execute the query and return the first DTO or default using Facet Projection.
    /// </summary>
    public async Task<TDto?> FirstOrDefaultDtoAsync<TDto>(CancellationToken cancellationToken = default) where TDto : class
    {
        return await _query.SelectFacet<TDto>().FirstOrDefaultAsync(cancellationToken);
    }
}
