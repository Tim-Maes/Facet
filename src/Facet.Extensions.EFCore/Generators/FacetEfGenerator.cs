using System.Collections.Immutable;
using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using Facet.Extensions.EFCore.Generators.Emission;
using Facet.Generation.Shared;

namespace Facet.Extensions.EFCore.Generators;

/// <summary>
/// Source generator for EF Core fluent navigation builders.
/// </summary>
[Generator(LanguageNames.CSharp)]
public sealed class FacetEfGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Read configuration from MSBuild properties
        var configProvider = context.AnalyzerConfigOptionsProvider
            .Select(static (options, _) => new FacetConfiguration(options));

        // Read EF model from JSON
        var efModel = EfJsonReader.Configure(context);

        // Discover Facet DTOs from attributes (both FacetAttribute and GenerateDtosAttribute)
        var facetDtos = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                "Facet.FacetAttribute",
                static (node, _) => node is ClassDeclarationSyntax or RecordDeclarationSyntax,
                static (context, cancellationToken) => FacetDtoInfo.TryCreate(context, cancellationToken))
            .Where(static dto => dto != null)
            .Select(static (dto, _) => dto!);

        // Also discover entities with GenerateDtosAttribute
        var generateDtoEntities = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                "Facet.GenerateDtosAttribute",
                static (node, _) => node is ClassDeclarationSyntax or RecordDeclarationSyntax,
                static (context, cancellationToken) => FacetDtoInfo.TryCreateFromGenerateDtos(context, cancellationToken))
            .Where(static dto => dto != null)
            .Select(static (dto, _) => dto!);

        // Also discover entities with GenerateAuditableDtosAttribute
        var generateAuditableDtoEntities = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                "Facet.GenerateAuditableDtosAttribute",
                static (node, _) => node is ClassDeclarationSyntax or RecordDeclarationSyntax,
                static (context, cancellationToken) => FacetDtoInfo.TryCreateFromGenerateDtos(context, cancellationToken))
            .Where(static dto => dto != null)
            .Select(static (dto, _) => dto!);

        // Combine all three sources of DTOs by collecting them first and deduplicate
        var allDtos = facetDtos.Collect()
            .Combine(generateDtoEntities.Collect())
            .Combine(generateAuditableDtoEntities.Collect())
            .Select(static (triple, _) => triple.Left.Left
                .Concat(triple.Left.Right)
                .Concat(triple.Right)
                .GroupBy(dto => dto.EntityTypeName)
                .Select(group => group.First())
                .ToImmutableArray());

        // Discover chain usage patterns in code
        var chainUses = ChainUseDiscovery.Configure(context);

        // Combine EF model with discovered DTOs, chain usage, and configuration
        var combined = efModel
            .Combine(allDtos)
            .Combine(chainUses.Collect())
            .Combine(configProvider)
            .Select(static (pair, _) => new {
                Model = pair.Left.Left.Left,
                Dtos = pair.Left.Left.Right,
                ChainUses = pair.Left.Right,
                Configuration = pair.Right
            });

        // Generate code
        context.RegisterSourceOutput(combined, static (context, data) =>
        {
            var efModel = data.Model;
            var facetDtos = data.Dtos;
            var chainUses = data.ChainUses;
            var config = data.Configuration;

            if (efModel == null)
            {
                context.ReportDiagnostic(Diagnostic.Create(
                    Diagnostics.InvalidModel,
                    Location.None,
                    "EF model is null - ensure efmodel.json is included as AdditionalFiles and properly formatted"));
                return;
            }

            var nonNullModel = efModel;

            // Generate diagnostic output
            var diagnosticContent = $@"// <auto-generated />
// Diagnostic Debug Output
// EF Model: {(efModel == null ? "NULL" : efModel.Contexts.Count.ToString() + " contexts")}
// Facet DTOs found: {facetDtos.Length}
// Entities in model: {(efModel == null ? "N/A" : string.Join(", ", efModel.Contexts.SelectMany(c => c.Entities).Select(e => e.Name + " (Clr: " + (e.Clr ?? "null") + ")")))}
// DTOs found: {string.Join(", ", facetDtos.Select(d => d.DtoTypeName + " (Entity: " + d.EntityTypeName + ")"))}
";
            context.AddSource("FacetEfDiagnostic.g.cs", SourceText.From(diagnosticContent, System.Text.Encoding.UTF8));

            if (facetDtos.Length == 0)
            {
                context.ReportDiagnostic(Diagnostic.Create(
                    Diagnostics.InvalidModel,
                    Location.None,
                    "No Facet DTOs discovered - ensure entities have [GenerateDtos] or DTOs have [Facet(typeof(Entity))] attributes"));
                return;
            }

            // Debug reporting if enabled
            if (config.EnableDebugOutput)
            {
                context.ReportDiagnostic(Diagnostic.Create(
                    Diagnostics.ChainDiscoveryDebug,
                    Location.None,
                    nonNullModel.Contexts.Count,
                    "EF Contexts",
                    string.Join(", ", nonNullModel.Contexts.Select(c => c.Context))));

                context.ReportDiagnostic(Diagnostic.Create(
                    Diagnostics.ChainDiscoveryDebug,
                    Location.None,
                    facetDtos.Length,
                    "Facet DTOs",
                    string.Join(", ", facetDtos.Select(d => d.EntityTypeName))));
            }

            // Apply depth capping with diagnostics using configured max depth
            var usedChains = ChainUseDiscovery.GroupAndNormalizeWithDepthCapping(chainUses, context, config.MaxChainDepth);

            // Emit debug information if enabled
            if (config.EnableDebugOutput)
            {
                foreach (var entityChains in usedChains)
                {
                    var chainList = string.Join(", ", entityChains.Value.Select(c => "'" + c + "'"));
                    context.ReportDiagnostic(Diagnostic.Create(
                        Diagnostics.ChainDiscoveryDebug,
                        Location.None,
                        entityChains.Value.Count,
                        entityChains.Key,
                        chainList));
                }
            }

            try
            {
                // Generate shape interfaces (base properties only - always linear)
                ShapeInterfacesEmitter.Emit(context, nonNullModel, facetDtos);

                // Generate capability interfaces (for navigation inclusion - always linear)
                CapabilityInterfacesEmitter.Emit(context, nonNullModel, facetDtos);

                // Generate fluent builders (conditional on discovered chains)
                FluentBuilderEmitter.Emit(context, nonNullModel, facetDtos, usedChains);

                // Generate selectors with EF includes (conditional on discovered chains)
                SelectorsEmitter.Emit(context, nonNullModel, facetDtos, usedChains);
            }
            catch (System.Exception ex)
            {
                context.ReportDiagnostic(Diagnostic.Create(
                    Diagnostics.GenerationError,
                    Location.None,
                    ex.Message));

                // Also generate a file with the exception details
                context.AddSource("FacetEfError.g.cs", SourceText.From($@"// Generation error
// Exception: {ex.GetType().Name}
// Message: {ex.Message}
// Stack trace:
// {ex.StackTrace}
", System.Text.Encoding.UTF8));
            }
        });
    }
}
