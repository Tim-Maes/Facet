using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Collections.Generic;

namespace Facet.Extensions.EFCore.Generators.Emission;

/// <summary>
/// Emits selectors and projection expressions for EF Core queries.
/// </summary>
internal static class SelectorsEmitter
{
    public static void Emit(SourceProductionContext context, ModelRoot efModel, ImmutableArray<FacetDtoInfo> facetDtos, 
        ImmutableDictionary<string, ImmutableHashSet<string>> usedChains)
    {
        foreach (var contextModel in efModel.Contexts)
        {
            foreach (var entity in contextModel.Entities)
            {
                // Find matching DTO
                var matchingDto = facetDtos.FirstOrDefault(dto => 
                    string.Equals(dto.EntityTypeName, entity.Clr, System.StringComparison.OrdinalIgnoreCase));

                if (matchingDto == null) continue;

                // Get used chains for this entity
                var entityName = GetSimpleTypeName(entity.Clr ?? entity.Name);
                var entityChains = usedChains.GetValueOrDefault(entityName, ImmutableHashSet<string>.Empty);

                GenerateSelectors(context, entity, matchingDto, entityChains);
            }
        }
    }

    private static void GenerateSelectors(SourceProductionContext context, EntityModel entity, FacetDtoInfo dtoInfo, ImmutableHashSet<string> usedChains)
    {
        var entityName = GetSimpleTypeName(entity.Clr ?? entity.Name);
        var selectorsName = $"{entityName}Selectors";
        
        var sb = new StringBuilder();
        
        // Generate file header
        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Linq;");
        sb.AppendLine("using System.Linq.Expressions;");
        sb.AppendLine("using System.Collections.Generic;");
        
        // Add using for entity namespace if different from DTO namespace
        var entityNamespace = GetNamespaceFromType(entity.Clr ?? entity.Name);
        if (!string.IsNullOrEmpty(entityNamespace) && entityNamespace != dtoInfo.DtoNamespace)
        {
            sb.AppendLine($"using {entityNamespace};");
        }
        
        sb.AppendLine();
        sb.AppendLine($"namespace {dtoInfo.DtoNamespace};");
        sb.AppendLine();
        
        // Generate shape implementation class first
        GenerateShapeImplementationClass(sb, entity, dtoInfo);
        
        // Generate selectors class
        sb.AppendLine($"/// <summary>");
        sb.AppendLine($"/// Projection selectors for {entityName} to various shapes.");
        sb.AppendLine($"/// </summary>");
        sb.AppendLine($"internal static class {selectorsName}");
        sb.AppendLine("{");
        
        // Always generate base shape selector (baseline)
        GenerateBaseShapeSelector(sb, entity, dtoInfo);
        
        // Only generate navigation shape selectors for used chains
        foreach (var navigation in entity.Navigations)
        {
            var navigationPath = navigation.Name;
            
            // Check if this navigation is used in any chain
            if (usedChains.Any(chain => chain.StartsWith(navigationPath, System.StringComparison.OrdinalIgnoreCase)))
            {
                GenerateNavigationShapeSelector(sb, entity, navigation, dtoInfo);
            }
        }
        
        sb.AppendLine("}");

        var sourceText = SourceText.From(sb.ToString(), System.Text.Encoding.UTF8);
        context.AddSource($"{selectorsName}.g.cs", sourceText);
    }

    private static void GenerateBaseShapeSelector(StringBuilder sb, EntityModel entity, FacetDtoInfo dtoInfo)
    {
        var entityName = GetSimpleTypeName(entity.Clr ?? entity.Name);
        var shapeClassName = $"{entityName}Shape";
        
        sb.AppendLine($"    /// <summary>");
        sb.AppendLine($"    /// Selector for base {entityName} shape (scalar properties only).");
        sb.AppendLine($"    /// </summary>");
        sb.AppendLine($"    public static Expression<Func<{entity.Clr}, I{entityName}Shape>> BaseShape {{ get; }} =");
        sb.AppendLine($"        entity => new {shapeClassName}");
        sb.AppendLine("        {");
        
        // Generate property mappings for scalar properties only
        // We'll focus on basic types and avoid navigation properties for the base shape
        GenerateScalarPropertyMappings(sb, entity, dtoInfo);
        
        sb.AppendLine("        };");
        sb.AppendLine();
    }

    private static void GenerateNavigationShapeSelector(StringBuilder sb, EntityModel entity, NavigationModel navigation, FacetDtoInfo dtoInfo)
    {
        var entityName = GetSimpleTypeName(entity.Clr ?? entity.Name);
        var navName = navigation.Name;
        var targetEntityName = GetSimpleTypeName(navigation.Target);
        
        sb.AppendLine($"    /// <summary>");
        sb.AppendLine($"    /// Selector for {entityName} with {navName} navigation included.");
        sb.AppendLine($"    /// </summary>");
        
        if (navigation.IsCollection)
        {
            sb.AppendLine($"    public static Expression<Func<{entity.Clr}, I{entityName}With{navName}<I{targetEntityName}Shape>>> With{navName}Shape {{ get; }} =");
            sb.AppendLine($"        entity => new {dtoInfo.DtoTypeName}With{navName}");
            sb.AppendLine("        {");
            
            // Generate base properties for the main entity
            GenerateScalarPropertyMappings(sb, entity, dtoInfo);
            
            sb.AppendLine($"            {navName} = entity.{navName}.Select(nav => new {GetTargetDtoName(navigation.Target)}");
            sb.AppendLine("            {");
            sb.AppendLine("                // TODO: Generate target entity property mappings");
            sb.AppendLine("                // This requires analyzing target entity properties");
            sb.AppendLine("            }).ToList()");
            sb.AppendLine("        };");
        }
        else
        {
            sb.AppendLine($"    public static Expression<Func<{entity.Clr}, I{entityName}With{navName}<I{targetEntityName}Shape>>> With{navName}Shape {{ get; }} =");
            sb.AppendLine($"        entity => new {dtoInfo.DtoTypeName}With{navName}");
            sb.AppendLine("        {");
            
            // Generate base properties for the main entity
            GenerateScalarPropertyMappings(sb, entity, dtoInfo);
            
            sb.AppendLine($"            {navName} = entity.{navName} == null ? null : new {GetTargetDtoName(navigation.Target)}");
            sb.AppendLine("            {");
            sb.AppendLine("                // TODO: Generate target entity property mappings");
            sb.AppendLine("                // This requires analyzing target entity properties");
            sb.AppendLine("            }");
            sb.AppendLine("        };");
        }
        
        sb.AppendLine();
    }

    private static string GetTargetDtoName(string targetEntityName)
    {
        var simpleName = GetSimpleTypeName(targetEntityName);
        return $"{simpleName}Dto"; // Assume DTO naming convention
    }

    private static void GenerateScalarPropertyMappings(StringBuilder sb, EntityModel entity, FacetDtoInfo dtoInfo)
    {
        // Generate property mappings based on actual DTO property analysis
        var scalarProperties = dtoInfo.Properties.Where(p => !p.IsNavigation).ToList();
        
        if (scalarProperties.Count == 0)
        {
            sb.AppendLine("            // No scalar properties found in DTO analysis");
            return;
        }
        
        for (int i = 0; i < scalarProperties.Count; i++)
        {
            var prop = scalarProperties[i];
            var isLast = i == scalarProperties.Count - 1;
            var comma = isLast ? "" : ",";
            
            // Generate property assignment - assuming entity has matching property
            sb.AppendLine($"            {prop.Name} = entity.{prop.Name}{comma}");
        }
    }
    
    private static void GenerateShapeImplementationClass(StringBuilder sb, EntityModel entity, FacetDtoInfo dtoInfo)
    {
        var entityName = GetSimpleTypeName(entity.Clr ?? entity.Name);
        var shapeClassName = $"{entityName}Shape";
        
        sb.AppendLine($"/// <summary>");
        sb.AppendLine($"/// Implementation of I{entityName}Shape for projection queries.");
        sb.AppendLine($"/// </summary>");
        sb.AppendLine($"internal sealed class {shapeClassName} : I{entityName}Shape");
        sb.AppendLine("{");
        
        // Generate properties that implement the interface
        var scalarProperties = dtoInfo.Properties.Where(p => !p.IsNavigation).ToList();
        
        foreach (var prop in scalarProperties)
        {
            sb.AppendLine($"    /// <summary>");
            sb.AppendLine($"    /// {prop.Name} property from the entity.");
            sb.AppendLine($"    /// </summary>");
            sb.AppendLine($"    public {prop.TypeName} {prop.Name} {{ get; set; }}");
            sb.AppendLine();
        }
        
        sb.AppendLine("}");
        sb.AppendLine();
    }
    
    private static string GetSimpleTypeName(string fullTypeName)
    {
        var lastDot = fullTypeName.LastIndexOf('.');
        return lastDot >= 0 ? fullTypeName.Substring(lastDot + 1) : fullTypeName;
    }
    
    private static string GetNamespaceFromType(string fullTypeName)
    {
        var lastDot = fullTypeName.LastIndexOf('.');
        return lastDot >= 0 ? fullTypeName.Substring(0, lastDot) : string.Empty;
    }
}