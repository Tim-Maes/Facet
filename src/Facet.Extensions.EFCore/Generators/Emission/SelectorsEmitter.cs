using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Collections.Generic;
using Facet.Extensions.EFCore.Generators.Shared;

namespace Facet.Extensions.EFCore.Generators.Emission;

/// <summary>
/// Emits selectors and projection expressions for EF Core queries.
/// </summary>
public static class SelectorsEmitter
{
    public static void Emit(SourceProductionContext context, ModelRoot efModel, ImmutableArray<FacetDtoInfo> facetDtos,
        ImmutableDictionary<string, ImmutableHashSet<string>> usedChains)
    {
        foreach (var contextModel in efModel.Contexts)
        {
            foreach (var entity in contextModel.Entities)
            {
                // Find matching DTO (handle global:: prefix)
                var entityClr = entity.Clr?.Replace("global::", "");
                var matchingDto = facetDtos.FirstOrDefault(dto =>
                {
                    var dtoEntityName = dto.EntityTypeName?.Replace("global::", "");
                    return string.Equals(dtoEntityName, entityClr, System.StringComparison.OrdinalIgnoreCase) ||
                           string.Equals(dtoEntityName, entity.Clr, System.StringComparison.OrdinalIgnoreCase);
                });

                if (matchingDto == null) continue;

                // Get used chains for this entity
                var entityName = GetSimpleTypeName(entity.Clr ?? entity.Name);
                var entityChains = usedChains.GetValueOrDefault(entityName, ImmutableHashSet<string>.Empty);

                GenerateSelectors(context, entity, matchingDto, entityChains);
            }
        }
    }

    private static void GenerateSelectors(SourceProductionContext context, EntityModel entity, FacetDtoInfo dtoInfo, ImmutableHashSet<string> usedChains)
    {
        var entityName = GetSimpleTypeName(entity.Clr ?? entity.Name);
        var selectorsName = $"{entityName}Selectors";

        var sb = new StringBuilder();

        // Generate file header
        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Linq;");
        sb.AppendLine("using System.Linq.Expressions;");
        sb.AppendLine("using System.Collections.Generic;");

        // Add using for entity namespace if different from DTO namespace
        var entityNamespace = GetNamespaceFromType(entity.Clr ?? entity.Name);
        if (!string.IsNullOrEmpty(entityNamespace) && entityNamespace != dtoInfo.DtoNamespace)
        {
            sb.AppendLine($"using {entityNamespace};");
        }

        sb.AppendLine();
        sb.AppendLine($"namespace {dtoInfo.DtoNamespace};");
        sb.AppendLine();

        // Generate shape implementation class first
        GenerateShapeImplementationClass(sb, entity, dtoInfo);

        // Generate selectors class
        sb.AppendLine($"/// <summary>");
        sb.AppendLine($"/// Projection selectors for {entityName} to various shapes.");
        sb.AppendLine($"/// </summary>");
        sb.AppendLine($"internal static class {selectorsName}");
        sb.AppendLine("{");

        // Always generate base shape selector (baseline)
        GenerateBaseShapeSelector(sb, entity, dtoInfo);

        // Only generate navigation shape selectors for used chains
        foreach (var navigation in entity.Navigations)
        {
            var navigationPath = navigation.Name;

            // For now always generate first-level navigation selector so fluent builder works even without chain discovery
            GenerateNavigationShapeSelector(sb, entity, navigation, dtoInfo);
        }

        sb.AppendLine("}");

        var sourceText = SourceText.From(sb.ToString(), System.Text.Encoding.UTF8);
        context.AddSource($"{selectorsName}.g.cs", sourceText);
    }

    private static void GenerateBaseShapeSelector(StringBuilder sb, EntityModel entity, FacetDtoInfo dtoInfo)
    {
        var entityName = GetSimpleTypeName(entity.Clr ?? entity.Name);
        var shapeClassName = $"{entityName}Shape";

        sb.AppendLine($"    /// <summary>");
        sb.AppendLine($"    /// Selector for base {entityName} shape (scalar properties only).");
        sb.AppendLine($"    /// </summary>");
        sb.AppendLine($"    public static Expression<Func<{entity.Clr}, I{entityName}Shape>> BaseShape {{ get; }} =");
        sb.AppendLine($"        entity => new {shapeClassName}");
        sb.AppendLine("        {");

        // Generate property mappings for scalar properties only
        // We'll focus on basic types and avoid navigation properties for the base shape
        GenerateScalarPropertyMappings(sb, entity, dtoInfo);

        sb.AppendLine("        };");
        sb.AppendLine();
    }

    private static void GenerateNavigationShapeSelector(StringBuilder sb, EntityModel entity, NavigationModel navigation, FacetDtoInfo dtoInfo)
    {
        var entityName = GetSimpleTypeName(entity.Clr ?? entity.Name);
        var navName = navigation.Name;
        var targetEntityName = GetSimpleTypeName(navigation.Target);

        sb.AppendLine($"    /// <summary>");
        sb.AppendLine($"    /// Selector for {entityName} with {navName} navigation included.");
        sb.AppendLine($"    /// </summary>");

        // We emit a shape implementation type for navigation composition inline (simple anonymous projection via concrete internal class)
        if (navigation.IsCollection)
        {
            sb.AppendLine($"    public static Expression<Func<{entity.Clr}, I{entityName}With{navName}<I{targetEntityName}Shape>>> With{navName}Shape {{ get; }} =");
            sb.AppendLine($"        entity => new {entityName}With{navName}Shape");
            sb.AppendLine("        {");
            GenerateScalarPropertyMappings(sb, entity, dtoInfo);
            sb.AppendLine($"            {navName} = entity.{navName}.Select(n => new {targetEntityName}Shape())" + (navigation.IsCollection ? ".ToList()" : ""));
            sb.AppendLine("        };");
        }
        else
        {
            sb.AppendLine($"    public static Expression<Func<{entity.Clr}, I{entityName}With{navName}<I{targetEntityName}Shape>>> With{navName}Shape {{ get; }} =");
            sb.AppendLine($"        entity => new {entityName}With{navName}Shape");
            sb.AppendLine("        {");
            GenerateScalarPropertyMappings(sb, entity, dtoInfo);
            sb.AppendLine($"            {navName} = entity.{navName} == null ? new {targetEntityName}Shape() : new {targetEntityName}Shape()");
            sb.AppendLine("        };");
        }

        sb.AppendLine();
    }

    private static string GetTargetDtoName(string targetEntityName)
    {
        var simpleName = GetSimpleTypeName(targetEntityName);
        return $"{simpleName}Dto"; // Assume DTO naming convention
    }

    private static void GenerateScalarPropertyMappings(StringBuilder sb, EntityModel entity, FacetDtoInfo dtoInfo)
    {
        // Generate property mappings based on actual DTO property analysis
        var scalarProperties = dtoInfo.Properties.Where(p => !p.IsNavigation).ToList();

        if (scalarProperties.Count == 0)
        {
            sb.AppendLine("            // No scalar properties found in DTO analysis");
            return;
        }

        // Map all scalar properties to avoid nullable reference warnings
        var mappedAny = false;
        foreach (var prop in scalarProperties)
        {
            if (mappedAny) sb.AppendLine(",");
            sb.Append($"            {prop.Name} = entity.{prop.Name}");
            mappedAny = true;
        }

        if (mappedAny)
        {
            sb.AppendLine();
        }
    }

    private static void GenerateShapeImplementationClass(StringBuilder sb, EntityModel entity, FacetDtoInfo dtoInfo)
    {
        var entityName = GetSimpleTypeName(entity.Clr ?? entity.Name);
    var shapeClassName = $"{entityName}Shape";

        sb.AppendLine($"/// <summary>");
        sb.AppendLine($"/// Implementation of I{entityName}Shape for projection queries.");
        sb.AppendLine($"/// </summary>");
        sb.AppendLine($"internal sealed class {shapeClassName} : I{entityName}Shape");
        sb.AppendLine("{");

        // Generate properties that implement the interface
        var scalarProperties = dtoInfo.Properties.Where(p => !p.IsNavigation).ToList();

        foreach (var prop in scalarProperties)
        {
            sb.AppendLine($"    /// <summary>");
            sb.AppendLine($"    /// {prop.Name} property from the entity.");
            sb.AppendLine($"    /// </summary>");

            // Add default value for non-nullable reference types to avoid CS8618
            var defaultValue = GetDefaultValueForType(prop.TypeName);
            if (!string.IsNullOrEmpty(defaultValue))
            {
                sb.AppendLine($"    public {prop.TypeName} {prop.Name} {{ get; set; }} = {defaultValue};");
            }
            else
            {
                sb.AppendLine($"    public {prop.TypeName} {prop.Name} {{ get; set; }}");
            }
            sb.AppendLine();
        }

        sb.AppendLine("}");
        sb.AppendLine();

        // Emit navigation composite shapes
        foreach (var nav in entity.Navigations)
        {
            var navName = nav.Name;
            var targetEntityName = GetSimpleTypeName(nav.Target);
            sb.AppendLine($"internal sealed class {entityName}With{navName}Shape : I{entityName}With{navName}<I{targetEntityName}Shape>");
            sb.AppendLine("{");
            foreach (var prop in scalarProperties)
            {
                sb.AppendLine($"    public {prop.TypeName} {prop.Name} {{ get; set; }}");
            }
            if (nav.IsCollection)
            {
                sb.AppendLine($"    public System.Collections.Generic.IReadOnlyList<I{targetEntityName}Shape> {navName} {{ get; set; }} = System.Array.Empty<I{targetEntityName}Shape>();");
            }
            else
            {
                sb.AppendLine($"    public I{targetEntityName}Shape {navName} {{ get; set; }} = null!;");
            }
            sb.AppendLine("}");
            sb.AppendLine();
        }
    }

    private static string GetSimpleTypeName(string fullTypeName)
    {
        var lastDot = fullTypeName.LastIndexOf('.');
        return lastDot >= 0 ? fullTypeName.Substring(lastDot + 1) : fullTypeName;
    }

    private static string GetNamespaceFromType(string fullTypeName)
    {
        var lastDot = fullTypeName.LastIndexOf('.');
        return lastDot >= 0 ? fullTypeName.Substring(0, lastDot) : string.Empty;
    }

    private static string GetDefaultValueForType(string typeName)
    {
        // Handle nullable types
        if (typeName.EndsWith("?"))
            return string.Empty; // nullable types don't need default values

        // Handle common non-nullable reference types
        if (typeName == "string" || typeName == "System.String")
            return "string.Empty";

        // Handle enums (assume they need default(EnumType))
        if (typeName.Contains("Behavior") || typeName.Contains("Status") || typeName.Contains("Type") ||
            (typeName.Contains(".") && char.IsUpper(typeName.Split('.').Last()[0]) && !typeName.StartsWith("System.")))
            return $"default({typeName})";

        // Handle other reference types (assume they need null! or default constructor)
        if (typeName.Contains(".") && !typeName.StartsWith("System.") ||
            char.IsUpper(typeName[0]) && !IsValueType(typeName))
            return "null!";

        return string.Empty; // Value types and others don't need explicit defaults
    }

    private static bool IsValueType(string typeName)
    {
        return typeName switch
        {
            "int" or "System.Int32" => true,
            "bool" or "System.Boolean" => true,
            "long" or "System.Int64" => true,
            "double" or "System.Double" => true,
            "float" or "System.Single" => true,
            "decimal" or "System.Decimal" => true,
            "byte" or "System.Byte" => true,
            "short" or "System.Int16" => true,
            "char" or "System.Char" => true,
            "System.Guid" => true,
            "System.DateTime" => true,
            "System.DateTimeOffset" => true,
            "System.TimeSpan" => true,
            _ => false
        };
    }
}
