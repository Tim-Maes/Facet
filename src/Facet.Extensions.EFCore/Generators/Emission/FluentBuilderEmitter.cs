using System;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

namespace Facet.Extensions.EFCore.Generators.Emission;

/// <summary>
/// Emits fluent builder classes that provide the With{Navigation}() API.
/// </summary>
internal static class FluentBuilderEmitter
{
    public static void Emit(SourceProductionContext context, ModelRoot efModel, ImmutableArray<FacetDtoInfo> facetDtos, ImmutableDictionary<string, ImmutableHashSet<string>> usedChains)
    {
        var generatedBuilders = new System.Collections.Generic.HashSet<string>();
        
        foreach (var contextModel in efModel.Contexts)
        {
            foreach (var entity in contextModel.Entities)
            {
                // Find matching DTO
                var matchingDto = facetDtos.FirstOrDefault(dto => 
                    string.Equals(dto.EntityTypeName, entity.Clr, System.StringComparison.OrdinalIgnoreCase));

                // Generate builder regardless of DTO match for entities with [GenerateDtos]
                if (matchingDto != null)
                {
                    var entityName = GetSimpleTypeName(entity.Clr ?? entity.Name);
                    var builderName = $"Facet{entityName}Builder";
                    
                    // Only generate if we haven't already generated this builder
                    if (generatedBuilders.Add(builderName))
                    {
                        GenerateFluentBuilder(context, entity, matchingDto, contextModel, usedChains);
                    }
                }
            }
        }

        // Generate the main DbContext extension methods as a separate file
        GenerateDbContextExtensionsFile(context, efModel, facetDtos);
    }

    private static void GenerateFluentBuilder(SourceProductionContext context, EntityModel entity, FacetDtoInfo dtoInfo, ContextModel contextModel, ImmutableDictionary<string, ImmutableHashSet<string>> usedChains)
    {
        var entityName = GetSimpleTypeName(entity.Clr ?? entity.Name);
        var builderName = $"Facet{entityName}Builder";
        
        var sb = new StringBuilder();
        
        // Generate file header
        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("using System.Linq;");
        sb.AppendLine("using System.Linq.Expressions;");
        sb.AppendLine("using System.Threading;");
        sb.AppendLine("using System.Threading.Tasks;");
        sb.AppendLine("using Microsoft.EntityFrameworkCore;");
        sb.AppendLine("using Facet.Extensions;");
        sb.AppendLine();
        sb.AppendLine($"namespace {dtoInfo.DtoNamespace};");
        sb.AppendLine();
        
        // Generate builder class
        sb.AppendLine($"/// <summary>");
        sb.AppendLine($"/// Fluent builder for {entityName} with navigation inclusion.");
        sb.AppendLine($"/// </summary>");
        sb.AppendLine($"public sealed class {builderName}<TShape>");
        sb.AppendLine("{");
        sb.AppendLine($"    private readonly IQueryable<{entity.Clr}> _query;");
        sb.AppendLine($"    private readonly List<string> _includes = new();");
        sb.AppendLine();
        
        // Constructor
        sb.AppendLine($"    public {builderName}(IQueryable<{entity.Clr}> query)");
        sb.AppendLine("    {");
        sb.AppendLine("        _query = query;");
        sb.AppendLine("    }");
        sb.AppendLine();
        
        // Get discovered chains for this entity
        var entityChains = usedChains.ContainsKey(entityName) ? usedChains[entityName] : ImmutableHashSet<string>.Empty;

        // Generate With{Navigation} methods for each navigation
        foreach (var navigation in entity.Navigations)
        {
            GenerateWithNavigationMethod(sb, navigation, entity, dtoInfo, entityChains);
        }
        
        // Generate query execution methods
        GenerateQueryMethods(sb, entity, dtoInfo);
        
        sb.AppendLine("}");

        var sourceText = SourceText.From(sb.ToString(), System.Text.Encoding.UTF8);
        context.AddSource($"{builderName}.g.cs", sourceText);
    }

    private static void GenerateWithNavigationMethod(StringBuilder sb, NavigationModel navigation, EntityModel entity, FacetDtoInfo dtoInfo, ImmutableHashSet<string> usedChains)
    {
        var entityName = GetSimpleTypeName(entity.Clr ?? entity.Name);
        var navName = navigation.Name;
        var targetEntityName = GetSimpleTypeName(navigation.Target);
        var builderName = $"Facet{entityName}Builder";
        
        sb.AppendLine($"    /// <summary>");
        sb.AppendLine($"    /// Include the {navName} navigation in the query.");
        sb.AppendLine($"    /// </summary>");
        
        // Always generate the basic WithX() method (baseline/linear generation)
        sb.AppendLine($"    public {builderName}<I{entityName}With{navName}<I{targetEntityName}Shape>> With{navName}()");
        sb.AppendLine("    {");
        sb.AppendLine($"        var newQuery = _query.Include(x => x.{navName});");
        sb.AppendLine($"        var newBuilder = new {builderName}<I{entityName}With{navName}<I{targetEntityName}Shape>>(newQuery);");
        sb.AppendLine($"        newBuilder._includes.AddRange(_includes);");
        sb.AppendLine($"        newBuilder._includes.Add(\"{navName}\");");
        sb.AppendLine("        return newBuilder;");
        sb.AppendLine("    }");
        
        // Check if this navigation path is used in discovered chains
        var hasNestedChains = usedChains.Any(chain => chain.StartsWith($"{navName}/", StringComparison.Ordinal));
        var isDirectlyUsed = usedChains.Contains(navName);
        
        // Only generate nested configuration methods if this navigation is used with nested paths
        // or if we have no chain discovery data at all (fallback behavior)
        if (hasNestedChains || usedChains.Count == 0)
        {
            sb.AppendLine();
            sb.AppendLine($"    /// <summary>");
            sb.AppendLine($"    /// Include the {navName} navigation with nested navigation configuration.");
            sb.AppendLine($"    /// </summary>");
            sb.AppendLine($"    public {builderName}<I{entityName}With{navName}<TNestedShape>> With{navName}<TNestedShape>(");
            sb.AppendLine($"        Func<Facet{targetEntityName}Builder<I{targetEntityName}Shape>, Facet{targetEntityName}Builder<TNestedShape>> configure)");
            sb.AppendLine("    {");
            sb.AppendLine($"        // This would require more complex EF Include handling for nested paths");
            sb.AppendLine($"        throw new NotImplementedException(\"Nested navigation configuration not yet implemented\");");
            sb.AppendLine("    }");
        }
        
        sb.AppendLine();
    }

    private static void GenerateQueryMethods(StringBuilder sb, EntityModel entity, FacetDtoInfo dtoInfo)
    {
        var entityName = GetSimpleTypeName(entity.Clr ?? entity.Name);
        
        // GetByIdAsync method
        sb.AppendLine($"    /// <summary>");
        sb.AppendLine($"    /// Get a single {entityName} by ID.");
        sb.AppendLine($"    /// </summary>");
        sb.AppendLine("    public async Task<TShape?> GetByIdAsync(object id, CancellationToken cancellationToken = default)");
        sb.AppendLine("    {");
        sb.AppendLine("        // For now, use simple Id-based filtering");
        sb.AppendLine("        // TODO: Enhance to use EF metadata for primary key discovery");
        sb.AppendLine("        var query = _query.Where(e => EF.Property<object>(e, \"Id\") == id);");
        sb.AppendLine();
        sb.AppendLine("        // Use SelectFacet to project to TShape");
        sb.AppendLine("        return await query.SelectFacet<TShape>().FirstOrDefaultAsync(cancellationToken);");
        sb.AppendLine("    }");
        sb.AppendLine();
        
        // ToListAsync method
        sb.AppendLine($"    /// <summary>");
        sb.AppendLine($"    /// Execute the query and return a list of {entityName} shapes.");
        sb.AppendLine($"    /// </summary>");
        sb.AppendLine("    public async Task<List<TShape>> ToListAsync(CancellationToken cancellationToken = default)");
        sb.AppendLine("    {");
        sb.AppendLine("        // Use SelectFacet to project to TShape and execute query");
        sb.AppendLine("        return await _query.SelectFacet<TShape>().ToListAsync(cancellationToken);");
        sb.AppendLine("    }");
        sb.AppendLine();
        
        // FirstOrDefaultAsync method
        sb.AppendLine($"    /// <summary>");
        sb.AppendLine($"    /// Execute the query and return the first {entityName} or default.");
        sb.AppendLine($"    /// </summary>");
        sb.AppendLine("    public async Task<TShape?> FirstOrDefaultAsync(CancellationToken cancellationToken = default)");
        sb.AppendLine("    {");
        sb.AppendLine("        // Use SelectFacet to project to TShape and execute query");
        sb.AppendLine("        return await _query.SelectFacet<TShape>().FirstOrDefaultAsync(cancellationToken);");
        sb.AppendLine("    }");
    }

    private static void GenerateDbContextExtensions(SourceProductionContext context, ModelRoot efModel, ImmutableArray<FacetDtoInfo> facetDtos)
    {
        // Don't generate separate DbContext extensions - they'll be part of the combined file generation
        // This method is now a placeholder for potential future use
    }

    private static void GenerateDbContextExtensionsFile(SourceProductionContext context, ModelRoot efModel, ImmutableArray<FacetDtoInfo> facetDtos)
    {
        var sb = new StringBuilder();
        
        // Generate file header
        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Linq;");
        sb.AppendLine("using System.Reflection;");
        sb.AppendLine("using Microsoft.EntityFrameworkCore;");
        sb.AppendLine("using Facet.Extensions;");
        sb.AppendLine();
        
        // Use the same namespace as the builders (first entity's namespace)
        var firstEntity = efModel.Contexts.FirstOrDefault()?.Entities.FirstOrDefault();
        var entityNamespace = firstEntity?.Clr != null ? 
            firstEntity.Clr.Substring(0, firstEntity.Clr.LastIndexOf('.')) : 
            "Generated.Facet.Extensions.EFCore";
        
        sb.AppendLine($"namespace {entityNamespace};");
        sb.AppendLine();
        
        sb.AppendLine("/// <summary>");
        sb.AppendLine("/// Extension methods for DbContext to enable fluent Facet navigation building.");
        sb.AppendLine("/// </summary>");
        sb.AppendLine("public static class FacetDbContextExtensions");
        sb.AppendLine("{");
        
        // Generate generic Facet<TEntity, TDto>() method
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Create a fluent builder for entity queries with navigation inclusion.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    /// <typeparam name=\"TEntity\">The entity type to query</typeparam>");
        sb.AppendLine("    /// <typeparam name=\"TDto\">The DTO type that TEntity will be projected to</typeparam>");
        sb.AppendLine("    /// <param name=\"context\">The DbContext</param>");
        sb.AppendLine("    /// <returns>A fluent builder for the specified entity type</returns>");
        sb.AppendLine("    public static object Facet<TEntity, TDto>(this DbContext context)");
        sb.AppendLine("        where TEntity : class");
        sb.AppendLine("        where TDto : class");
        sb.AppendLine("    {");
        sb.AppendLine("        // Validate that TDto has a Projection property (required by SelectFacet)");
        sb.AppendLine("        var projectionProperty = typeof(TDto).GetProperty(");
        sb.AppendLine("            \"Projection\",");
        sb.AppendLine("            BindingFlags.Public | BindingFlags.Static);");
        sb.AppendLine("            ");
        sb.AppendLine("        if (projectionProperty == null)");
        sb.AppendLine("        {");
        sb.AppendLine("            throw new InvalidOperationException(");
        sb.AppendLine("                $\"DTO type '{typeof(TDto).Name}' does not have a static 'Projection' property. \" +");
        sb.AppendLine("                \"Ensure the DTO is generated by Facet or manually implements the Projection property.\");");
        sb.AppendLine("        }");
        sb.AppendLine("        ");
        sb.AppendLine("        var entityName = typeof(TEntity).Name;");
        sb.AppendLine("        // Use reflection to create the appropriate builder type");
        sb.AppendLine("        // This is a placeholder - actual implementation would use generated builders");
        sb.AppendLine("        throw new NotImplementedException($\"Fluent builder for {entityName} not yet implemented\");");
        sb.AppendLine("    }");
        sb.AppendLine();
        
        // Generate specific Facet{EntityName}() methods for each entity that return fluent builders
        foreach (var contextModel in efModel.Contexts)
        {
            foreach (var entity in contextModel.Entities)
            {
                var matchingDto = facetDtos.FirstOrDefault(dto => 
                    string.Equals(dto.EntityTypeName, entity.Clr, System.StringComparison.OrdinalIgnoreCase));

                if (matchingDto == null) continue;

                var entityName = GetSimpleTypeName(entity.Clr ?? entity.Name);
                var builderName = $"Facet{entityName}Builder";
                
                sb.AppendLine($"    /// <summary>");
                sb.AppendLine($"    /// Create a fluent builder for {entityName} queries.");
                sb.AppendLine($"    /// </summary>");
                sb.AppendLine($"    public static {builderName}<I{entityName}Shape> Facet{entityName}(this DbContext context)");
                sb.AppendLine("    {");
                sb.AppendLine($"        var query = context.Set<{entity.Clr}>().AsNoTracking();");
                sb.AppendLine($"        return new {builderName}<I{entityName}Shape>(query);");
                sb.AppendLine("    }");
                sb.AppendLine();
            }
        }
        
        sb.AppendLine("}");

        var sourceText = SourceText.From(sb.ToString(), System.Text.Encoding.UTF8);
        context.AddSource("FacetDbContextExtensions.g.cs", sourceText);
    }

    private static string GetSimpleTypeName(string fullTypeName)
    {
        var lastDot = fullTypeName.LastIndexOf('.');
        return lastDot >= 0 ? fullTypeName.Substring(lastDot + 1) : fullTypeName;
    }
}