using Microsoft.CodeAnalysis;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Facet.Generators;

/// <summary>
/// Orchestrates the generation of complete facet type source code.
/// </summary>
internal static class CodeBuilder
{
    /// <summary>
    /// Generates the complete source code for a facet type.
    /// </summary>
    public static string Generate(FacetTargetModel model, Dictionary<string, FacetTargetModel> facetLookup)
    {
        var sb = new StringBuilder();
        GenerateFileHeader(sb);

        // Collect all namespaces from referenced types
        var namespacesToImport = CodeGenerationHelpers.CollectNamespaces(model);

        // Generate using statements for all required namespaces
        foreach (var ns in namespacesToImport.OrderBy(x => x))
        {
            sb.AppendLine($"using {ns};");
        }
        sb.AppendLine();

        // Nullable must be enabled in generated code with a directive
        var hasNullableRefTypeMembers = model.Members.Any(m => !m.IsValueType && m.TypeName.EndsWith("?"));
        if (hasNullableRefTypeMembers)
        {
            sb.AppendLine("#nullable enable");
            sb.AppendLine();
        }

        if (!string.IsNullOrWhiteSpace(model.Namespace))
        {
            sb.AppendLine($"namespace {model.Namespace};");
        }

        // Generate containing type hierarchy for nested classes
        var containingTypeIndent = GenerateContainingTypeHierarchy(sb, model);

        // Generate type-level XML documentation if available
        if (!string.IsNullOrWhiteSpace(model.TypeXmlDocumentation))
        {
            var indentedDocumentation = model.TypeXmlDocumentation!.Replace("\n", $"\n{containingTypeIndent}");
            sb.AppendLine($"{containingTypeIndent}{indentedDocumentation}");
        }

        var keyword = GetTypeKeyword(model);
        var isPositional = model.IsRecord && !model.HasExistingPrimaryConstructor;
        var hasInitOnlyProperties = model.Members.Any(m => m.IsInitOnly);
        var hasRequiredProperties = model.Members.Any(m => m.IsRequired);
        var hasCustomMapping = !string.IsNullOrWhiteSpace(model.ConfigurationTypeName);

        // Only generate positional declaration if there's no existing primary constructor
        if (isPositional)
        {
            GeneratePositionalDeclaration(sb, model, keyword, containingTypeIndent);
        }

        sb.AppendLine($"{containingTypeIndent}public partial {keyword} {model.Name}");
        sb.AppendLine($"{containingTypeIndent}{{");

        var memberIndent = containingTypeIndent + "    ";

        // Generate properties if not positional OR if there's an existing primary constructor
        if (!isPositional || model.HasExistingPrimaryConstructor)
        {
            MemberGenerator.GenerateMembers(sb, model, memberIndent);
        }

        // Generate constructor
        if (model.GenerateConstructor)
        {
            ConstructorGenerator.GenerateConstructor(sb, model, isPositional, hasInitOnlyProperties, hasCustomMapping, hasRequiredProperties);
        }

        // Generate parameterless constructor if requested
        if (model.GenerateParameterlessConstructor)
        {
            ConstructorGenerator.GenerateParameterlessConstructor(sb, model, isPositional);
        }

        // Generate projection
        if (model.GenerateExpressionProjection)
        {
            ProjectionGenerator.GenerateProjectionProperty(sb, model, memberIndent, facetLookup);
        }

        // Generate reverse mapping method (BackTo)
        if (model.GenerateBackTo)
        {
            BackToGenerator.GenerateBackToMethod(sb, model);
        }

        sb.AppendLine($"{containingTypeIndent}}}");

        // Close containing type braces
        CloseContainingTypeHierarchy(sb, model, containingTypeIndent);

        return sb.ToString();
    }

    #region Private Helper Methods

    private static void GenerateFileHeader(StringBuilder sb)
    {
        sb.AppendLine("// <auto-generated>");
        sb.AppendLine($"//     This code was generated by the Facet source generator v{FacetConstants.GeneratorVersion}.");
        sb.AppendLine("//     Changes to this file may cause incorrect behavior and will be lost if");
        sb.AppendLine("//     the code is regenerated.");
        sb.AppendLine("// </auto-generated>");
        sb.AppendLine();
    }

    private static string GenerateContainingTypeHierarchy(StringBuilder sb, FacetTargetModel model)
    {
        var containingTypeIndent = "";
        foreach (var containingType in model.ContainingTypes)
        {
            sb.AppendLine($"{containingTypeIndent}public partial class {containingType}");
            sb.AppendLine($"{containingTypeIndent}{{");
            containingTypeIndent += "    ";
        }
        return containingTypeIndent;
    }

    private static void CloseContainingTypeHierarchy(StringBuilder sb, FacetTargetModel model, string containingTypeIndent)
    {
        // Close containing type braces
        for (int i = model.ContainingTypes.Length - 1; i >= 0; i--)
        {
            containingTypeIndent = containingTypeIndent.Substring(0, containingTypeIndent.Length - 4);
            sb.AppendLine($"{containingTypeIndent}}}");
        }
    }

    private static string GetTypeKeyword(FacetTargetModel model)
    {
        return (model.TypeKind, model.IsRecord) switch
        {
            (TypeKind.Class, false) => "class",
            (TypeKind.Class, true) => "record",
            (TypeKind.Struct, true) => "record struct",
            (TypeKind.Struct, false) => "struct",
            _ => "class",
        };
    }

    private static void GeneratePositionalDeclaration(StringBuilder sb, FacetTargetModel model, string keyword, string indent)
    {
        var parameters = string.Join(", ",
            model.Members.Select(m =>
            {
                var param = $"{m.TypeName} {m.Name}";
                // Add required modifier for positional parameters if needed
                if (m.IsRequired && model.TypeKind == TypeKind.Struct && model.IsRecord)
                {
                    param = $"required {param}";
                }
                return param;
            }));
        sb.AppendLine($"{indent}public partial {keyword} {model.Name}({parameters});");
    }

    #endregion
}
