using Facet.Generators.Shared;
using Facet.Generators.FacetGenerators;
using Microsoft.CodeAnalysis;
using System.Linq;
using System.Text;

namespace Facet.Generators.FlattenGenerators;

/// <summary>
/// Generates C# code for flattened target types.
/// </summary>
internal static class FlattenCodeBuilder
{
    public static string Generate(FlattenTargetModel model)
    {
        var sb = new StringBuilder();

        // File header
        sb.AppendLine("// <auto-generated>");
        sb.AppendLine($"//     This code was generated by the Facet source generator v{typeof(FlattenCodeBuilder).Assembly.GetName().Version}.");
        sb.AppendLine("//     Changes to this file may cause incorrect behavior and will be lost if");
        sb.AppendLine("//     the code is regenerated.");
        sb.AppendLine("// </auto-generated>");
        sb.AppendLine();

        // Using statements
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Linq;");
        sb.AppendLine("using System.Linq.Expressions;");
        sb.AppendLine();

        // Namespace
        if (!string.IsNullOrEmpty(model.Namespace))
        {
            sb.AppendLine($"namespace {model.Namespace};");
        }

        // Handle nested types
        foreach (var containingType in model.ContainingTypes)
        {
            sb.AppendLine($"public partial {containingType}");
            sb.AppendLine("{");
        }

        // Type declaration
        var typeKeyword = GetTypeKeyword(model);
        sb.AppendLine($"public partial {typeKeyword} {model.Name}");
        sb.AppendLine("{");

        // Generate properties
        GenerateProperties(sb, model);

        // Generate constructor
        GenerateConstructor(sb, model);

        // Generate parameterless constructor
        if (model.GenerateParameterlessConstructor)
        {
            GenerateParameterlessConstructor(sb, model);
        }

        // Generate projection
        if (model.GenerateProjection)
        {
            GenerateProjection(sb, model);
        }

        // Close type declaration
        sb.AppendLine("}");

        // Close containing types
        for (int i = 0; i < model.ContainingTypes.Length; i++)
        {
            sb.AppendLine("}");
        }

        return sb.ToString();
    }

    private static void GenerateProperties(StringBuilder sb, FlattenTargetModel model)
    {
        foreach (var property in model.Properties)
        {
            // XML documentation
            if (!string.IsNullOrWhiteSpace(property.XmlDocumentation))
            {
                sb.AppendLine($"    {property.XmlDocumentation}");
            }
            else
            {
                sb.AppendLine("    /// <summary>");
                sb.AppendLine($"    /// Flattened from source path: {property.SourcePath}");
                sb.AppendLine("    /// </summary>");
            }

            // Property declaration
            sb.AppendLine($"    public {property.TypeName} {property.Name} {{ get; set; }}");
            sb.AppendLine();
        }
    }

    private static void GenerateConstructor(StringBuilder sb, FlattenTargetModel model)
    {
        sb.AppendLine("    /// <summary>");
        sb.AppendLine($"    /// Initializes a new instance of the <see cref=\"{model.Name}\"/> class from the specified <see cref=\"{CodeGenerationHelpers.GetSimpleTypeName(model.SourceTypeName)}\"/>.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine($"    /// <param name=\"source\">The source <see cref=\"{CodeGenerationHelpers.GetSimpleTypeName(model.SourceTypeName)}\"/> object to flatten.</param>");
        sb.AppendLine("    /// <remarks>");
        sb.AppendLine("    /// This constructor automatically flattens all nested properties into top-level properties.");
        sb.AppendLine("    /// </remarks>");
        sb.AppendLine($"    public {model.Name}({model.SourceTypeName} source)");
        sb.AppendLine("    {");

        // Generate property assignments
        foreach (var property in model.Properties)
        {
            // Build null-conditional path: source.Address?.Street
            var path = BuildNullConditionalPath(property.PathSegments);
            sb.AppendLine($"        this.{property.Name} = source.{path};");
        }

        sb.AppendLine("    }");
        sb.AppendLine();
    }

    private static void GenerateParameterlessConstructor(StringBuilder sb, FlattenTargetModel model)
    {
        sb.AppendLine("    /// <summary>");
        sb.AppendLine($"    /// Initializes a new instance of the <see cref=\"{model.Name}\"/> class with default values.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    /// <remarks>");
        sb.AppendLine("    /// This constructor is useful for unit testing, object initialization, and scenarios");
        sb.AppendLine("    /// where you need to create an empty instance and populate properties later.");
        sb.AppendLine("    /// </remarks>");
        sb.AppendLine($"    public {model.Name}()");
        sb.AppendLine("    {");
        sb.AppendLine("    }");
        sb.AppendLine();
    }

    private static void GenerateProjection(StringBuilder sb, FlattenTargetModel model)
    {
        sb.AppendLine("    /// <summary>");
        sb.AppendLine($"    /// Gets the projection expression for converting <see cref=\"{CodeGenerationHelpers.GetSimpleTypeName(model.SourceTypeName)}\"/> to <see cref=\"{model.Name}\"/>.");
        sb.AppendLine("    /// Use this for LINQ and Entity Framework query projections.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    /// <value>An expression tree that can be used in LINQ queries for efficient database projections.</value>");
        sb.AppendLine("    /// <example>");
        sb.AppendLine("    /// <code>");
        sb.AppendLine($"    /// var dtos = context.{CodeGenerationHelpers.GetSimpleTypeName(model.SourceTypeName)}s");
        sb.AppendLine("    ///     .Where(x => x.IsActive)");
        sb.AppendLine($"    ///     .Select({model.Name}.Projection)");
        sb.AppendLine("    ///     .ToList();");
        sb.AppendLine("    /// </code>");
        sb.AppendLine("    /// </example>");
        sb.AppendLine($"    public static Expression<Func<{model.SourceTypeName}, {model.Name}>> Projection =>");
        sb.AppendLine($"        source => new {model.Name}");
        sb.AppendLine("        {");

        // Generate property initializers
        for (int i = 0; i < model.Properties.Length; i++)
        {
            var property = model.Properties[i];
            var comma = i < model.Properties.Length - 1 ? "," : "";
            var path = BuildDotPath(property.PathSegments);
            sb.AppendLine($"            {property.Name} = source.{path}{comma}");
        }

        sb.AppendLine("        };");
        sb.AppendLine();
    }

    private static string BuildNullConditionalPath(System.Collections.Immutable.ImmutableArray<string> segments)
    {
        if (segments.Length == 1)
        {
            return segments[0];
        }

        // Build: Address?.Street or Address?.Country?.Name
        return string.Join("?.", segments);
    }

    private static string BuildDotPath(System.Collections.Immutable.ImmutableArray<string> segments)
    {
        // Build: Address.Street or Address.Country.Name
        return string.Join(".", segments);
    }

    private static string GetTypeKeyword(FlattenTargetModel model)
    {
        return (model.TypeKind, model.IsRecord) switch
        {
            (TypeKind.Class, false) => "class",
            (TypeKind.Class, true) => "record",
            (TypeKind.Struct, true) => "record struct",
            (TypeKind.Struct, false) => "struct",
            _ => "class",
        };
    }
}
