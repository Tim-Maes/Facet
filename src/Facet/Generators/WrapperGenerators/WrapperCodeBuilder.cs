using Facet.Generators.Shared;
using Microsoft.CodeAnalysis;
using System.Linq;
using System.Text;

namespace Facet.Generators;

/// <summary>
/// Orchestrates the generation of complete wrapper type source code.
/// </summary>
internal static class WrapperCodeBuilder
{
    /// <summary>
    /// Generates the complete source code for a wrapper type.
    /// </summary>
    public static string Generate(WrapperTargetModel model)
    {
        var sb = new StringBuilder();
        GenerateFileHeader(sb);

        // Collect all namespaces from referenced types
        var namespacesToImport = CodeGenerationHelpers.CollectNamespacesForWrapper(model);

        // Generate using statements for all required namespaces
        foreach (var ns in namespacesToImport.OrderBy(x => x))
        {
            sb.AppendLine($"using {ns};");
        }

        sb.AppendLine();

        // Nullable must be enabled in generated code with a directive
        var hasNullableRefTypeMembers = model.Members.Any(m => !m.IsValueType && m.TypeName.EndsWith("?"));
        if (hasNullableRefTypeMembers)
        {
            sb.AppendLine("#nullable enable");
            sb.AppendLine();
        }

        if (!string.IsNullOrWhiteSpace(model.Namespace))
        {
            sb.AppendLine($"namespace {model.Namespace};");
        }

        // Generate containing type hierarchy for nested classes
        var containingTypeIndent = GenerateContainingTypeHierarchy(sb, model);

        // Generate type-level XML documentation if available
        if (!string.IsNullOrWhiteSpace(model.TypeXmlDocumentation))
        {
            var indentedDocumentation = model.TypeXmlDocumentation!.Replace("\n", $"\n{containingTypeIndent}");
            sb.AppendLine($"{containingTypeIndent}{indentedDocumentation}");
        }

        var keyword = GetTypeKeyword(model);

        sb.AppendLine($"{containingTypeIndent}public partial {keyword} {model.Name}");
        sb.AppendLine($"{containingTypeIndent}{{");

        var memberIndent = containingTypeIndent + "    ";

        // Generate private readonly source field
        sb.AppendLine($"{memberIndent}private readonly {model.SourceTypeName} {model.SourceFieldName};");
        sb.AppendLine();

        // Generate delegating properties
        WrapperMemberGenerator.GenerateMembers(sb, model, memberIndent);

        // Generate constructor
        WrapperConstructorGenerator.GenerateConstructor(sb, model, memberIndent);

        // Generate Unwrap method
        GenerateUnwrapMethod(sb, model, memberIndent);

        sb.AppendLine($"{containingTypeIndent}}}");

        // Close containing type braces
        CloseContainingTypeHierarchy(sb, model, containingTypeIndent);

        return sb.ToString();
    }

    #region Private Helper Methods

    private static void GenerateFileHeader(StringBuilder sb)
    {
        sb.AppendLine("// <auto-generated>");
        sb.AppendLine($"//     This code was generated by the Facet Wrapper source generator v{FacetConstants.GeneratorVersion}.");
        sb.AppendLine("//     Changes to this file may cause incorrect behavior and will be lost if");
        sb.AppendLine("//     the code is regenerated.");
        sb.AppendLine("// </auto-generated>");
        sb.AppendLine();
    }

    private static string GenerateContainingTypeHierarchy(StringBuilder sb, WrapperTargetModel model)
    {
        var containingTypeIndent = "";
        foreach (var containingType in model.ContainingTypes)
        {
            // Don't specify accessibility for containing types - they're already defined in user code
            sb.AppendLine($"{containingTypeIndent}partial class {containingType}");
            sb.AppendLine($"{containingTypeIndent}{{");
            containingTypeIndent += "    ";
        }
        return containingTypeIndent;
    }

    private static void CloseContainingTypeHierarchy(StringBuilder sb, WrapperTargetModel model, string containingTypeIndent)
    {
        // Close containing type braces
        for (int i = model.ContainingTypes.Length - 1; i >= 0; i--)
        {
            containingTypeIndent = containingTypeIndent.Substring(0, containingTypeIndent.Length - 4);
            sb.AppendLine($"{containingTypeIndent}}}");
        }
    }

    private static string GetTypeKeyword(WrapperTargetModel model)
    {
        return (model.TypeKind, model.IsRecord) switch
        {
            (TypeKind.Class, false) => "class",
            (TypeKind.Class, true) => "record",
            (TypeKind.Struct, true) => "record struct",
            (TypeKind.Struct, false) => "struct",
            _ => "class",
        };
    }

    private static void GenerateUnwrapMethod(StringBuilder sb, WrapperTargetModel model, string indent)
    {
        sb.AppendLine();
        sb.AppendLine($"{indent}/// <summary>");
        sb.AppendLine($"{indent}/// Returns the wrapped source object.");
        sb.AppendLine($"{indent}/// </summary>");
        sb.AppendLine($"{indent}public {model.SourceTypeName} Unwrap() => {model.SourceFieldName};");
    }

    #endregion
}
