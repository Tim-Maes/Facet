using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Generic;

namespace Facet.Extensions.EFCore.Generators.Emission;

/// <summary>
/// Emits shape interfaces that define the base scalar properties of entities.
/// </summary>
public static class ShapeInterfacesEmitter
{
    public static void Emit(SourceProductionContext context, ModelRoot efModel, ImmutableArray<FacetDtoInfo> facetDtos)
    {
        // Consolidate all shape interfaces and implementations into a single file to avoid circular dependencies
        var sb = new StringBuilder();

        // Generate file header
        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();

        // Use the first DTO's namespace, or fallback
        var targetNamespace = facetDtos.FirstOrDefault()?.DtoNamespace ?? "Generated";
        sb.AppendLine($"namespace {targetNamespace};");
        sb.AppendLine();

        var validEntities = new List<(EntityModel entity, FacetDtoInfo dto)>();

        // First pass: collect all valid entities and their DTOs
        foreach (var contextModel in efModel.Contexts)
        {
            foreach (var entity in contextModel.Entities)
            {
                var entityClr = entity.Clr?.Replace("global::", "");
                var matchingDto = facetDtos.FirstOrDefault(dto =>
                {
                    var dtoEntityName = dto.EntityTypeName?.Replace("global::", "");
                    return string.Equals(dtoEntityName, entityClr, System.StringComparison.OrdinalIgnoreCase) ||
                           string.Equals(dtoEntityName, entity.Clr, System.StringComparison.OrdinalIgnoreCase);
                });

                if (matchingDto != null)
                {
                    validEntities.Add((entity, matchingDto));
                }
            }
        }

        // Generate all shape interfaces first
        foreach (var (entity, dto) in validEntities)
        {
            GenerateShapeInterfaceInline(sb, entity, dto);
        }

        // Generate all capability interfaces (depend on shape interfaces)
        foreach (var (entity, dto) in validEntities)
        {
            GenerateCapabilityInterfacesInline(sb, entity, dto);
        }

        // Generate all shape implementation classes
        foreach (var (entity, dto) in validEntities)
        {
            GenerateShapeImplementationInline(sb, entity, dto);
        }

        // Generate all navigation composite shapes
        foreach (var (entity, dto) in validEntities)
        {
            GenerateNavigationShapesInline(sb, entity, dto, validEntities);
        }

        var sourceText = SourceText.From(sb.ToString(), System.Text.Encoding.UTF8);
        context.AddSource("AllShapeInterfaces.g.cs", sourceText);
    }

    private static void GenerateShapeInterface(SourceProductionContext context, EntityModel entity, FacetDtoInfo dtoInfo)
    {
        var entityName = GetSimpleTypeName(entity.Clr ?? entity.Name);
        var interfaceName = $"I{entityName}Shape";

        var sb = new StringBuilder();

        // Generate file header
        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine($"namespace {dtoInfo.DtoNamespace};");
        sb.AppendLine();

        // Apply TypeScript attributes if configured
        foreach (var tsAttribute in dtoInfo.TypeScriptAttributes)
        {
            sb.AppendLine(tsAttribute);
        }

        // Generate shape interface
        sb.AppendLine($"/// <summary>");
        sb.AppendLine($"/// Defines the shape of {entityName} with scalar properties only.");
        sb.AppendLine($"/// </summary>");
        sb.AppendLine($"public interface {interfaceName}");
        sb.AppendLine("{");

        // Generate properties from DTO analysis
        GenerateShapeProperties(sb, dtoInfo);

        sb.AppendLine("}");

        var sourceText = SourceText.From(sb.ToString(), System.Text.Encoding.UTF8);
        context.AddSource($"{interfaceName}.g.cs", sourceText);
    }

    private static void GenerateShapeProperties(StringBuilder sb, FacetDtoInfo dtoInfo)
    {
        var scalarProperties = dtoInfo.Properties.Where(p => !p.IsNavigation).ToList();

        if (scalarProperties.Count == 0)
        {
            sb.AppendLine("    // No scalar properties found in DTO analysis");
            return;
        }

        foreach (var prop in scalarProperties)
        {
            sb.AppendLine($"    /// <summary>");
            sb.AppendLine($"    /// {prop.Name} property from the entity.");
            sb.AppendLine($"    /// </summary>");
            sb.AppendLine($"    {prop.TypeName} {prop.Name} {{ get; }}");
            sb.AppendLine();
        }
    }

    private static void GenerateShapeInterfaceInline(StringBuilder sb, EntityModel entity, FacetDtoInfo dtoInfo)
    {
        var entityName = GetSimpleTypeName(entity.Clr ?? entity.Name);
        var interfaceName = $"I{entityName}Shape";

        // Apply TypeScript attributes if configured
        foreach (var tsAttribute in dtoInfo.TypeScriptAttributes)
        {
            sb.AppendLine(tsAttribute);
        }

        // Generate shape interface
        sb.AppendLine($"/// <summary>");
        sb.AppendLine($"/// Defines the shape of {entityName} with scalar properties only.");
        sb.AppendLine($"/// </summary>");
        sb.AppendLine($"public interface {interfaceName}");
        sb.AppendLine("{");

        // Generate properties from DTO analysis
        GenerateShapeProperties(sb, dtoInfo);

        sb.AppendLine("}");
        sb.AppendLine();
    }

    private static void GenerateShapeImplementationInline(StringBuilder sb, EntityModel entity, FacetDtoInfo dtoInfo)
    {
        var entityName = GetSimpleTypeName(entity.Clr ?? entity.Name);
        var shapeClassName = $"{entityName}Shape";

        sb.AppendLine($"/// <summary>");
        sb.AppendLine($"/// Implementation of I{entityName}Shape for projection queries.");
        sb.AppendLine($"/// </summary>");
        sb.AppendLine($"internal sealed class {shapeClassName} : I{entityName}Shape");
        sb.AppendLine("{");

        // Generate properties that implement the interface
        var scalarProperties = dtoInfo.Properties.Where(p => !p.IsNavigation).ToList();

        foreach (var prop in scalarProperties)
        {
            sb.AppendLine($"    /// <summary>");
            sb.AppendLine($"    /// {prop.Name} property from the entity.");
            sb.AppendLine($"    /// </summary>");
            sb.AppendLine($"    public {prop.TypeName} {prop.Name} {{ get; set; }}");
            sb.AppendLine();
        }

        sb.AppendLine("}");
        sb.AppendLine();
    }

    private static void GenerateCapabilityInterfacesInline(StringBuilder sb, EntityModel entity, FacetDtoInfo dtoInfo)
    {
        if (!entity.Navigations.Any()) return;

        var entityName = GetSimpleTypeName(entity.Clr ?? entity.Name);

        // Generate capability interfaces for each navigation
        foreach (var navigation in entity.Navigations)
        {
            var navName = navigation.Name;
            var targetEntityName = GetSimpleTypeName(navigation.Target);
            var interfaceName = $"I{entityName}With{navName}<TShape>";

            sb.AppendLine($"/// <summary>");
            sb.AppendLine($"/// Capability interface for {entityName} with {navName} navigation included.");
            sb.AppendLine($"/// </summary>");
            sb.AppendLine($"/// <typeparam name=\"TShape\">The shape of the included {navName} navigation.</typeparam>");
            sb.AppendLine($"public interface I{entityName}With{navName}<TShape> : I{entityName}Shape");
            sb.AppendLine("{");

            if (navigation.IsCollection)
            {
                sb.AppendLine($"    /// <summary>");
                sb.AppendLine($"    /// The included {navName} collection.");
                sb.AppendLine($"    /// </summary>");
                sb.AppendLine($"    System.Collections.Generic.IReadOnlyList<TShape> {navName} {{ get; }}");
            }
            else
            {
                sb.AppendLine($"    /// <summary>");
                sb.AppendLine($"    /// The included {navName} navigation.");
                sb.AppendLine($"    /// </summary>");
                sb.AppendLine($"    TShape {navName} {{ get; }}");
            }

            sb.AppendLine("}");
            sb.AppendLine();
        }
    }

    private static void GenerateNavigationShapesInline(StringBuilder sb, EntityModel entity, FacetDtoInfo dtoInfo, List<(EntityModel entity, FacetDtoInfo dto)> allEntities)
    {
        var entityName = GetSimpleTypeName(entity.Clr ?? entity.Name);
        var scalarProperties = dtoInfo.Properties.Where(p => !p.IsNavigation).ToList();

        // Generate navigation composite shapes for this entity
        foreach (var nav in entity.Navigations)
        {
            var navName = nav.Name;
            var targetEntityName = GetSimpleTypeName(nav.Target);

            sb.AppendLine($"/// <summary>");
            sb.AppendLine($"/// Shape for {entityName} with {navName} navigation included.");
            sb.AppendLine($"/// </summary>");
            sb.AppendLine($"internal sealed class {entityName}With{navName}Shape : I{entityName}With{navName}<I{targetEntityName}Shape>");
            sb.AppendLine("{");

            foreach (var prop in scalarProperties)
            {
                sb.AppendLine($"    public {prop.TypeName} {prop.Name} {{ get; set; }}");
            }

            if (nav.IsCollection)
            {
                sb.AppendLine($"    public System.Collections.Generic.IReadOnlyList<I{targetEntityName}Shape> {navName} {{ get; set; }} = System.Array.Empty<I{targetEntityName}Shape>();");
            }
            else
            {
                sb.AppendLine($"    public I{targetEntityName}Shape {navName} {{ get; set; }} = null!;");
            }

            sb.AppendLine("}");
            sb.AppendLine();
        }
    }

    private static string GetSimpleTypeName(string fullTypeName)
    {
        var lastDot = fullTypeName.LastIndexOf('.');
        return lastDot >= 0 ? fullTypeName.Substring(lastDot + 1) : fullTypeName;
    }
}
