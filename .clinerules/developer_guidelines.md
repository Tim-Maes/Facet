# Facet Developer Guidelines

## Overview
Facet is a C# source generator library that enables compile-time DTO generation, projections, and mapping without runtime overhead. The library consists of multiple packages that work together to provide a complete projection and mapping solution for .NET applications.

## Project Structure
- **src/Facet/** — Core source generator library (attributes, generators, shared utilities)
- **src/Facet.Extensions/** — Provider-agnostic extension methods for mapping and projections
- **src/Facet.Mapping/** — Advanced static mapping configuration with async support
- **src/Facet.Mapping.Expressions/** — Expression tree transformation utilities
- **src/Facet.Extensions.EFCore/** — Entity Framework Core-specific async extensions
- **src/Facet.Extensions.EFCore.Mapping/** — Advanced EF Core custom mapper support with DI
- **test/Facet.Tests/** — Comprehensive unit and integration tests
- **docs/** — Documentation and guides

## Build & Runtime Commands
- `dotnet build` or `dotnet build Facet.sln` — Compiles the entire solution
- `dotnet test` — Runs all tests in the test project
- `dotnet test --filter "FullyQualifiedName~{TestCategory}"` — Runs specific test category (e.g., GenerateDtos, Facet, Flatten)
- `dotnet pack` — Creates NuGet packages for distribution
- `dotnet build --no-incremental` — Clean build (useful when generator changes aren't being picked up)

**Important**: Source generators cache aggressively. If changes to generators aren't reflected:
1. Clean the solution: `dotnet clean`
2. Delete `obj/` and `bin/` directories
3. Rebuild with `dotnet build --no-incremental`

## Architecture Patterns

### Source Generator Structure (src/Facet/Generators/)
All generators follow Roslyn's incremental generator pattern:

- **FacetGenerator.cs** — Generates projections from `[Facet]` attribute
- **GenerateDtosGenerator.cs** — Generates CRUD DTOs from `[GenerateDtos]` and `[GenerateAuditableDtos]`
- **FlattenGenerator.cs** — Generates flattened DTOs from `[Flatten]` attribute
- **Shared/** — Common utilities (`GeneratorUtilities.cs`, `AttributeValidator.cs`, etc.)

**Key Principles**:
- Use incremental generators (`IIncrementalGenerator`) for performance
- Generators must be deterministic and stateless
- Use `ForAttributeWithMetadataName` for attribute-based discovery
- Always handle `CancellationToken` to support incremental compilation
- Generated code should include `#nullable enable` directive
- Use `<auto-generated>` header in all generated files
- Never throw exceptions in generators — swallow and return null instead

### Generator Hint Names
- Hint names (file names passed to `context.AddSource()`) **cannot contain** invalid filename characters like `:`, `<`, `>`, `|`, etc.
- For types in global namespace, strip the `global::` prefix before building hint names
- Use `.GetSafeName()` extension method for complex type names

### Model Structure
Each generator defines target models that capture attribute data:
- `FacetTargetModel` — For `[Facet]` attribute
- `GenerateDtosTargetModel` — For `[GenerateDtos]` attribute
- `FlattenTargetModel` — For `[Flatten]` attribute
- `FacetMember` — Represents properties/fields with metadata (nullability, init-only, required)

### Extension Methods (src/Facet.Extensions/)
- Static extension methods for `ToFacet<T>()`, `SelectFacets<T>()`, `ToSource<T>()`
- Generic overloads: parameterless (`ToFacet<TTarget>()`) and typed (`ToFacet<TSource, TTarget>()`)
- Typed versions are faster due to avoiding reflection
- Always provide both sync and async variants where applicable

### EF Core Integration (src/Facet.Extensions.EFCore/)
- Use `IQueryable<T>` extensions for database projections
- Leverage `SelectFacet<T>()` for compile-time LINQ expressions
- `ToFacetsAsync()` for materialized async operations
- Navigation properties auto-loaded via expression analysis (no `.Include()` needed)

## Code Conventions

### C# Style
- **Namespace style**: File-scoped namespaces (`namespace Facet.Generators;`)
- **Indentation**: 4 spaces (no tabs)
- **Naming**:
  - PascalCase for public APIs, types, properties, methods
  - `_camelCase` for private fields
  - `camelCase` for local variables and parameters
- **Null handling**: Use nullable reference types (`#nullable enable`)
- **String interpolation**: Prefer `$"..."` over `string.Format()` or concatenation
- **Collections**: Use `ImmutableArray<T>` for generator models

### XML Documentation
- **Mandatory** for all public APIs (types, methods, properties)
- Use `<summary>`, `<param>`, `<returns>`, `<example>` tags
- Include usage examples for complex features
- Preserve XML docs in generated code where applicable

### Generated Code Quality
- Always include file header with `<auto-generated>` comment
- Enable nullable reference types with `#nullable enable`
- Add XML doc comments with `<summary>` explaining the purpose
- Include the source type in generated type documentation
- For constructors, document parameters and purpose
- Include usage examples in projection properties

### Error Handling in Generators
```csharp
try
{
    // Generator logic
}
catch (Exception)
{
    // Swallow exceptions to prevent generator crashes
    // Optionally emit a diagnostic instead
    return null;
}
```

Never let exceptions bubble up from generators — this crashes the compilation.

## Testing Requirements

### Test Organization
Tests are organized by feature in `test/Facet.Tests/`:
- **UnitTests/Core/** — Core generator functionality tests
  - `Facet/` — `[Facet]` attribute tests
  - `GenerateDtos/` — `[GenerateDtos]` tests
  - `Flatten/` — `[Flatten]` tests
- **UnitTests/Extensions/** — Extension method tests
- **IntegrationTests/** — End-to-end scenarios
- **TestModels/** — Test entities and DTOs

### Test Conventions
- Use xUnit framework
- Test class naming: `{Feature}{Aspect}Tests.cs` (e.g., `FacetGeneratorTests.cs`)
- Test method naming: `{Method}_{Scenario}_{ExpectedBehavior}` (e.g., `ToFacet_WithNestedObject_MapsCorrectly`)
- Use `[Fact]` for simple tests, `[Theory]` with `[InlineData]` for parameterized tests
- Always test edge cases: global namespace, nullable types, collections, nested objects

### Coverage Requirements
- **All generators** must have tests covering:
  - Basic generation scenario
  - Global namespace classes (no namespace)
  - Nullable reference types
  - Collections (List, Array, IEnumerable)
  - Nested objects
  - Complex types (generics, nullable value types)
  - Edge cases (empty classes, read-only fields, init-only properties)

### Running Tests
```bash
# Run all tests
dotnet test

# Run specific test category
dotnet test --filter "FullyQualifiedName~GenerateDtos"

# Run tests with detailed output
dotnet test --logger "console;verbosity=detailed"
```

## Problem-Solving Workflow

### For Source Generator Issues
1. **Reproduce**: Create minimal test case in `test/Facet.Tests/TestModels/`
2. **Debug**:
   - Check generated files in `obj/Generated/Facet/`
   - Use `#if DEBUG` to output diagnostics during development
   - Attach debugger to generator process (set `DOTNET_CLI_UI_LANGUAGE=en` and use VS)
3. **Fix**: Implement focused fix in the appropriate generator
4. **Test**: Add regression test to prevent future issues
5. **Verify**: Run full test suite to ensure no regressions

### For Extension Method Issues
1. **Isolate**: Create unit test that reproduces the issue
2. **Verify Generated Code**: Ensure the generator produces correct projections
3. **Fix Extension Logic**: Update extension method implementation
4. **Performance**: Consider both generic (`<T>`) and typed (`<TSource, TTarget>`) variants

## Git Workflow

### Branching Strategy
- **Main Branch**: `master` (stable, release-ready code)
- **Feature Branches**: `feature/issue-{id}-{description}` or `feature/{description}`
- **Bug Fixes**: `fix/issue-{id}-{description}` or `fix/{description}`
- **Enhancements**: `enhancement/issue-{id}-{description}`

### Branch Creation
```bash
git checkout master
git pull origin master
git checkout -b fix/issue-140-global-namespace-hint-name
```

### Commit Message Format
Follow conventional commits:
```
{type}({scope}): {description}

{optional body}

{optional footer}
```

**Types**:
- `fix` — Bug fixes
- `feat` — New features
- `docs` — Documentation changes
- `test` — Test additions or modifications
- `refactor` — Code refactoring without behavior changes
- `perf` — Performance improvements
- `chore` — Build process, dependencies, tooling

**Scopes**: `generator`, `facet`, `dtos`, `flatten`, `extensions`, `efcore`, `tests`, `docs`

**Examples**:
```
fix(generator): handle global namespace in GetSimpleTypeName

The method now strips the global:: prefix before extracting type name,
preventing invalid characters in hint names.

Fixes #140
```

```
feat(dtos): add support for record structs in GenerateDtos

Users can now specify OutputType.RecordStruct for value-type DTOs.

Closes #123
```

### Pull Request Guidelines
1. Reference the issue number in PR title: `Fix #140: Handle global namespace in DTO generation`
2. Provide clear description of changes
3. Include test results (all tests must pass)
4. Update documentation if adding new features
5. Ensure no breaking changes unless major version bump

## Key Design Principles

### 1. Zero Runtime Cost
All code generation happens at compile time. Generated code should be as efficient as hand-written code.

### 2. Type Safety
Leverage C#'s type system. No reflection at runtime (except in non-generic extension methods).

### 3. Developer Experience
- Intuitive attribute-based API
- Rich IntelliSense support
- Clear error messages via diagnostics
- Comprehensive XML documentation

### 4. Compatibility
- Support .NET Standard 2.0 for Facet (generator)
- Support .NET 6+ for extensions
- Support EF Core 6+ for EF Core packages

### 5. Performance
- Incremental generators for fast compilation
- Cached expression trees for projections
- Typed generic methods for best performance

## Common Pitfalls

### Source Generator Development
- **Forgetting to handle global namespace**: Always check for and strip `global::` prefix
- **Invalid hint names**: Sanitize type names before using as file names
- **Non-deterministic generation**: Ensure generators produce same output for same input
- **Ignoring cancellation tokens**: Always pass and check `CancellationToken`
- **Throwing exceptions**: Swallow exceptions and return null or emit diagnostics

### Testing
- **Missing global namespace tests**: Always test classes with and without namespaces
- **Forgetting edge cases**: Test nullable types, collections, nested objects, etc.
- **Not verifying generated code**: Check `obj/Generated/` to ensure correct output

### Extension Methods
- **Providing typed overloads**: Always offer `<TSource, TTarget>` (performance) and `<TTarget>`
- **Mixing sync/async**: Provide both variants consistently

## Documentation Requirements

### When Adding New Features
1. Update relevant README.md in package directory
2. Add examples to main README.md
3. Create or update docs in `docs/` directory
4. Add XML documentation to all public APIs
5. Include usage examples in XML docs

### Documentation Style
- Use clear, concise language
- Provide code examples for all features
- Show both basic and advanced usage
- Explain "why" not just "what"
- Include performance considerations where relevant

## References

- [Roslyn Source Generators Cookbook](https://github.com/dotnet/roslyn/blob/main/docs/features/source-generators.cookbook.md)
- [Incremental Generators](https://github.com/dotnet/roslyn/blob/main/docs/features/incremental-generators.md)
- [C# Coding Conventions](https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/coding-style/coding-conventions)
- **Project Documentation**: `docs/README.md`
- **Comprehensive Blog Post**: [Facets in .NET](https://tim-maes.com/blog/2025/09/28/facets-in-dotnet-(2)/)

## Quick Reference

### Adding a New Generator Feature
1. Update or create the target model in `src/Facet/Generators/{GeneratorName}/`
2. Implement the generator logic following `IIncrementalGenerator` pattern
3. Add test entities to `test/Facet.Tests/TestModels/`
4. Create comprehensive tests in `test/Facet.Tests/UnitTests/Core/`
5. Verify generated code in `obj/Generated/Facet/`
6. Update documentation and examples

### Debugging Generator Issues
1. Check `obj/Generated/Facet/{GeneratorName}/` for generated files
2. Use `dotnet build --no-incremental` to force regeneration
3. Add test case in `test/Facet.Tests/` to reproduce
4. Verify hint names don't contain invalid characters
5. Check for proper null handling and cancellation token usage

### Before Committing
- [ ] All tests pass (`dotnet test`)
- [ ] Code follows conventions (file-scoped namespaces, XML docs, etc.)
- [ ] Added tests for new features or bug fixes
- [ ] Updated documentation if needed
- [ ] Verified generated code quality
- [ ] No breaking changes (or documented if necessary)
